<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Ğ¡Ğ¿Ğ°ÑĞ¸ ĞœĞ¾Ğ½Ğ°Ñ€Ñ…Ğ° â€” Ğ¼Ğ°Ñ‚Ñ‡â€‘3 + ÑĞ¿Ğ°ÑĞµĞ½Ğ¸Ğµ</title>
  <meta name="description" content="ĞŸĞ¾Ñ€Ñ‚Ñ€ĞµÑ‚Ğ½Ğ°Ñ HTML5â€‘Ğ¸Ğ³Ñ€Ğ°: ÑĞ½Ğ¸Ğ·Ñƒ Ğ¼Ğ°Ñ‚Ñ‡â€‘3, ÑĞ²ĞµÑ€Ñ…Ñƒ Ğ¼Ğ¾Ğ½Ğ°Ñ€Ñ… Ğ² Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸. ĞšÑ€Ğ°ÑĞ¸Ğ²Ğ°Ñ, Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ñ‡Ğ¸Ğ²Ğ°Ñ, Ğ±ĞµĞ· Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹." />
  <style>
    :root{
      --bg:#0f1222;
      --bg-panel:#171a33;
      --ink:#e6e8ff;
      --muted:#a9afd6;
      --accent:#7c9bff;
      --accent-2:#f6b76b;
      --danger:#ff5a7a;
      --success:#4ee1a0;
      --gold:#ffd166;
      --shadow:rgba(0,0,0,.35);
      --glass:rgba(255,255,255,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 80% -10%, #233 0%, rgba(0,0,0,0) 70%),
        radial-gradient(1400px 900px at 0% 0%, #19203b 0%, rgba(0,0,0,0) 70%),
        linear-gradient(180deg, #0b0e1a 0%, #10132a 100%);
      color:var(--ink);
      font: 15px/1.35 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol";
      overflow:hidden;
      touch-action:none; /* Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºÑƒ Ğ¿Ñ€Ğ¸ ÑĞ²Ğ°Ğ¹Ğ¿Ğ°Ñ… Ğ½Ğ° Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ñ… */
    }
    .wrap{
      height:100dvh; /* ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ğ° Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ñ… */
      display:grid;
      grid-template-rows: 56px 1fr;
      gap:10px;
      padding:10px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:8px 10px;
      box-shadow: 0 12px 30px var(--shadow);
      backdrop-filter: blur(8px);
    }
    .title{
      display:flex; align-items:center; gap:10px;
      font-weight:800; letter-spacing: .2px;
      text-shadow: 0 2px 8px rgba(0,0,0,.3);
      user-select:none;
    }
    .crown{
      width:28px; height:28px; display:inline-grid; place-items:center;
      background: radial-gradient(circle at 50% 30%, #fff7, #fff0),
                  linear-gradient(180deg, #ffdf7e, #f0b030);
      box-shadow: inset 0 -2px 4px rgba(0,0,0,.2), 0 4px 10px rgba(0,0,0,.4);
      border-radius:6px;
      clip-path: polygon(8% 65%, 25% 35%, 35% 65%, 50% 28%, 64% 65%, 75% 35%, 92% 65%, 92% 86%, 8% 86%);
    }
    .controls{
      display:flex; gap:8px; align-items:center;
    }
    .btn{
      appearance:none; border:0; cursor:pointer; color:var(--ink);
      padding:8px 12px; border-radius:10px;
      background: linear-gradient(180deg, #2a2f59, #1b1f3b);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 2px 0 rgba(255,255,255,.08);
      font-weight:700;
    }
    .btn:active{ transform: translateY(1px) scale(.995); }
    .btn.secondary{
      background: linear-gradient(180deg, #2a2b35, #1b1c29);
    }
    select{
      appearance:none; background: linear-gradient(180deg, #2a2f59, #1b1f3b);
      color:var(--ink); border-radius:10px; padding:8px 12px; border:1px solid rgba(255,255,255,.08);
      font-weight:700;
      box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 2px 0 rgba(255,255,255,.08);
    }

    .main{
      display:grid;
      grid-template-rows: 1fr auto;
      gap:10px;
      min-height:0; /* Ğ²Ğ°Ğ¶Ğ½Ğ¾: Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹ÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ Ğ²Ñ‹ÑĞ¾Ñ‚Ñ‹ Ğ³Ñ€Ğ¸Ğ´-ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² */
    }

    .panel{
      position:relative;
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      background: radial-gradient(1600px 800px at 80% -10%, rgba(255,255,255,.06), rgba(255,255,255,.02)),
                  linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.04));
      box-shadow: 0 20px 40px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
      min-height:0;
    }

    .scene{
      display:grid; grid-template-rows: 1fr; min-height:0;
    }
    .board{
      display:grid; grid-template-rows: 1fr; min-height: 300px;
    }

    canvas{ width:100%; height:100%; display:block; }
    .hud{
      position:absolute; left:10px; right:10px; top:10px; display:flex; gap:8px; align-items:center;
      z-index:5; pointer-events:none;
    }
    .meter{
      flex:1; height:14px; border-radius:999px; overflow:hidden;
      background: rgba(255,255,255,.1);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 1px 2px rgba(0,0,0,.5);
    }
    .meter > .fill{
      height:100%; width:40%; background: linear-gradient(90deg, #ff6f91, #ffa26f);
      box-shadow: 0 4px 12px rgba(255,100,120,.45);
      transition: width .25s ease-out;
    }
    .hud .pill{
      pointer-events:auto;
      padding:6px 10px; border-radius:999px; background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(6px);
      font-weight:800; font-feature-settings: "tnum" 1; letter-spacing:.3px;
      display:flex; gap:6px; align-items:center;
    }
    .hud .pill .dot{ width:10px; height:10px; border-radius:999px; background: var(--success); box-shadow:0 0 12px var(--success); }
    .hud .pill.red .dot{ background: var(--danger); box-shadow:0 0 12px var(--danger); }

    .overlay{
      position:absolute; inset:0; display:none; place-items:center; background: rgba(0,0,0,.55);
      z-index:10;
    }
    .overlay.show{ display:grid; }
    .dialog{
      width:min(92%, 520px); border-radius:18px; padding:24px; background: linear-gradient(180deg, #1b1f3e, #12152a);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 30px 60px rgba(0,0,0,.6), inset 0 1px 0 rgba(255,255,255,.08);
      text-align:center;
    }
    .big{
      font-size:26px; font-weight:900; margin:0 0 8px; letter-spacing:.4px;
      text-shadow: 0 4px 18px rgba(0,0,0,.5);
    }
    .sub{ color: var(--muted); margin-bottom:16px; }
    .dialog .actions{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
    .pill-btn{
      cursor:pointer; padding:10px 16px; border-radius:999px; font-weight:800; border:0;
      background: linear-gradient(180deg, #2b2f59, #1c1f3b); color:var(--ink);
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 18px rgba(0,0,0,.45), inset 0 2px 0 rgba(255,255,255,.06);
    }
    .pill-btn:active{ transform: translateY(1px); }
    .pill-btn.gold{ background: linear-gradient(180deg, #ffd166, #d8a52e); color:#2c2100; }

    .legend{
      position:absolute; right:10px; bottom:10px; left:10px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:center;
      z-index:3; pointer-events:none;
    }
    .tag{
      pointer-events:auto;
      background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      padding:6px 10px; border-radius:999px; font-weight:700; color:var(--muted);
      display:flex; gap:6px; align-items:center;
    }
    .tag .swatch{ width:12px; height:12px; border-radius:3px; }
    .tag strong{ color:var(--ink); }

    @media (min-aspect-ratio: 10/16){
      .main{ grid-template-rows: 1fr min(52vh, 680px); }
    }
    @media (max-aspect-ratio: 10/16){
      .main{ grid-template-rows: 1fr min(60vh, 760px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <div class="crown"></div>
        <div>Ğ¡ĞŸĞĞ¡Ğ˜ ĞœĞĞĞĞ Ğ¥Ğ</div>
      </div>
      <div class="controls">
        <select id="mode">
          <option value="lava">ğŸŒ‹ Ğ ĞµĞ¶Ğ¸Ğ¼: Ğ›Ğ°Ğ²Ğ°</option>
          <option value="dragon">ğŸ‰ Ğ ĞµĞ¶Ğ¸Ğ¼: Ğ”Ñ€Ğ°ĞºĞ¾Ğ½</option>
          <option value="ceiling">ğŸ§± Ğ ĞµĞ¶Ğ¸Ğ¼: ĞŸĞ¾Ñ‚Ğ¾Ğ»Ğ¾Ğº</option>
        </select>
        <button class="btn" id="btnRestart">ĞŸĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑĞº</button>
        <button class="btn secondary" id="btnPause">ĞŸĞ°ÑƒĞ·Ğ°</button>
      </div>
    </header>

    <div class="main">
      <div class="panel scene">
        <div class="hud">
          <div class="pill" id="comboPill"><span class="dot"></span> ĞšĞ¾Ğ¼Ğ±Ğ¾: <span id="comboVal">x1</span></div>
          <div class="meter"><div class="fill" id="dangerFill"></div></div>
          <div class="pill red">ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ</div>
        </div>
        <canvas id="scene"></canvas>
        <div class="legend">
          <div class="tag"><div class="swatch" style="background:#ff6f91"></div> <span>Ğ¡Ğ±Ñ€Ğ¾Ñ Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ Ğ·Ğ° Ñ‚Ğ°Ğ¹Ğ»</span> <strong>âˆ’1</strong></div>
          <div class="tag"><div class="swatch" style="background:#4ee1a0"></div> <span>Ğ‘Ğ¾Ğ½ÑƒÑ ĞºĞ°ÑĞºĞ°Ğ´Ğ°</span> <strong>+20%</strong></div>
          <div class="tag"><div class="swatch" style="background:#7c9bff"></div> <span>ĞšĞ¾Ğ¼Ğ±Ğ¾-Ğ¼Ğ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ</span> <strong>Ğ´Ğ¾ Ã—5</strong></div>
        </div>
      </div>

      <div class="panel board">
        <canvas id="board"></canvas>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="dialog">
        <div class="big" id="overlayTitle">ĞŸĞ¾Ğ±ĞµĞ´Ğ°!</div>
        <div class="sub" id="overlaySub">ĞœĞ¾Ğ½Ğ°Ñ€Ñ… ÑĞ¿Ğ°ÑÑ‘Ğ½. Ğ¡Ñ‹Ğ³Ñ€Ğ°ĞµĞ¼ ĞµÑ‰Ñ‘?</div>
        <div class="actions">
          <button class="pill-btn gold" id="btnAgain">Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ ÑĞ½Ğ¾Ğ²Ğ°</button>
          <button class="pill-btn" id="btnContinue">ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ</button>
        </div>
      </div>
    </div>

  </div>

<script>
/*  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Ğ¡ĞŸĞĞ¡Ğ˜ ĞœĞĞĞĞ Ğ¥Ğ â€” Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ°Ñ‚Ñ‡â€‘3 Ğ¿Ñ€Ğ¾Ñ‚Ğ¾Ñ‚Ğ¸Ğ¿ Ñ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¹ ÑÑ†ĞµĞ½Ğ¾Ğ¹â€‘Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒÑ.
    ĞĞ¸ĞºĞ°ĞºĞ¸Ñ… Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ñ‹Ñ… Ğ¼Ğ°Ñ€Ğ¾Ğº/Ğ°ÑÑĞµÑ‚Ğ¾Ğ² Ñ‚Ñ€ĞµÑ‚ÑŒĞ¸Ñ… Ğ»Ğ¸Ñ†. Ğ’ÑÑ‘ Ñ€Ğ¸ÑÑƒĞµÑ‚ÑÑ Canvas'Ğ¾Ğ¼.
    Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ:
      â€¢ ĞŸĞš: ĞºĞ»Ğ¸Ğº/Ğ¿ĞµÑ€ĞµÑ‚Ğ°ÑĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¾ÑĞµĞ´Ğ½Ğ¸Ñ… Ñ„Ğ¸ÑˆĞµĞº.
      â€¢ ĞœĞ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹: Ñ‚Ğ°Ñ‡/ÑĞ²Ğ°Ğ¹Ğ¿ ÑĞ¾ÑĞµĞ´Ğ½Ğ¸Ñ… Ñ„Ğ¸ÑˆĞµĞº.
    Ğ¦ĞµĞ»ÑŒ:
      â€¢ Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ â‰¥3 ÑĞ½Ğ¸Ğ·Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞ°Ñ‚ÑŒ Â«ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒÂ» ÑĞ²ĞµÑ€Ñ…Ñƒ (Ğ»Ğ°Ğ²Ğ°/Ğ´Ñ€Ğ°ĞºĞ¾Ğ½/Ğ¿Ğ¾Ñ‚Ğ¾Ğ»Ğ¾Ğº).
      â€¢ Ğ’Ñ‹Ğ¸Ğ³Ñ€Ñ‹Ñˆ â€” ĞºĞ¾Ğ³Ğ´Ğ° ÑˆĞºĞ°Ğ»Ğ° Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ÑÑ Ğ´Ğ¾ Ğ½ÑƒĞ»Ñ.
      â€¢ ĞŸĞ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ â€” ĞºĞ¾Ğ³Ğ´Ğ° ÑˆĞºĞ°Ğ»Ğ° Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ.
    Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸:
      â€¢ ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ HTML, Ğ±ĞµĞ· Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹.
      â€¢ ĞŸĞ¾Ñ€Ñ‚Ñ€ĞµÑ‚, Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ğ², Ñ€ĞµÑ‚Ğ¸Ğ½Ğ°â€‘ÑĞºĞµĞ¹Ğ»Ğ¸Ğ½Ğ³, pointer events, ÑˆĞµĞ¹Ğ´Ğ¸Ğ½Ğ³Ğ¸/Ñ‡Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹.
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a, b, t) => a + (b - a) * t;
const rnd = (a=1, b=0) => Math.random() * (a - b) + b;
const easeOut = t => 1 - Math.pow(1 - t, 3);
const easeInOut = t => t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
let idCounter=1; const uid=()=>idCounter++;

function hsl(h, s=70, l=50, a=1){ return `hsla(${h} ${s}% ${l}% / ${a})`; }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CONFIG = {
  rows: 8,
  cols: 8,
  tileTypes: 6,
  gravity: 1600, // px/s^2
  swapSpeed: 12, // ĞºĞ»ĞµÑ‚Ğ¾Ğº Ğ² ÑĞµĞºÑƒĞ½Ğ´Ñƒ
  clearShrinkTime: .22,
  fallSpeed: 14, // ĞºĞ»ĞµÑ‚Ğ¾Ğº Ğ² ÑĞµĞºÑƒĞ½Ğ´Ñƒ (Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ)
  spawnDelayPerRow: .03,
  baseHazardRise: .040, // Ğ² Ğ´Ğ¾Ğ»ÑÑ… ÑˆĞºĞ°Ğ»Ñ‹/ÑĞµĞº
  hazardPerTile: .012,   // ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¡ĞĞ˜Ğ–ĞĞ•Ğœ Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ·Ğ° Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚Ğ°Ğ¹Ğ»
  cascadeBonus: .20,     // +20% ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ·Ğ° ĞºĞ°Ğ¶Ğ´ÑƒÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰ÑƒÑ Ğ²Ğ¾Ğ»Ğ½Ñƒ Ğ² ĞºĞ°ÑĞºĞ°Ğ´Ğµ
  maxComboMultiplier: 5,
  shuffleIfNoMoves: true,
  portraitBoardScale: .94, // Ğ´Ğ¾Ğ»Ñ Ğ²Ñ‹ÑĞ¾Ñ‚Ñ‹ Ğ½Ğ¸Ğ¶Ğ½ĞµĞ¹ Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸ Ğ¾Ñ‚Ğ²ĞµĞ´Ñ‘Ğ½Ğ½Ğ°Ñ Ğ¿Ğ¾Ğ´ Ğ¿Ğ¾Ğ»Ğµ
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞšĞ°Ğ½Ğ²Ğ°ÑÑ‹ Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sceneCanvas = document.getElementById('scene');
const boardCanvas = document.getElementById('board');
const sceneCtx = sceneCanvas.getContext('2d');
const boardCtx = boardCanvas.getContext('2d', { alpha: true });

let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
let viewport = { w: 0, h: 0 };
let boardRectPx = { x:0, y:0, w:0, h:0, cell: 0 };

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const scenePanel = sceneCanvas.parentElement.getBoundingClientRect();
  const boardPanel = boardCanvas.parentElement.getBoundingClientRect();

  // SCENE
  sceneCanvas.width = Math.floor(scenePanel.width * DPR);
  sceneCanvas.height = Math.floor(scenePanel.height * DPR);
  sceneCanvas.style.width = scenePanel.width + "px";
  sceneCanvas.style.height = scenePanel.height + "px";

  // BOARD
  boardCanvas.width = Math.floor(boardPanel.width * DPR);
  boardCanvas.height = Math.floor(boardPanel.height * DPR);
  boardCanvas.style.width = boardPanel.width + "px";
  boardCanvas.style.height = boardPanel.height + "px";

  // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€ÑĞ¼Ğ¾ÑƒĞ³Ğ¾Ğ»ÑŒĞ½Ğ¸Ğº Ğ¿Ğ¾Ğ»Ñ Ñ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ°Ğ¼Ğ¸, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸.
  const cols = CONFIG.cols, rows = CONFIG.rows;
  const padding = 16 * DPR;
  const usableW = boardCanvas.width - padding*2;
  const usableH = boardCanvas.height - padding*2;
  const cell = Math.floor(Math.min(usableW/cols, usableH/rows));
  const boardW = cell * cols;
  const boardH = cell * rows;
  boardRectPx = {
    x: Math.floor((boardCanvas.width - boardW)/2),
    y: Math.floor((boardCanvas.height - boardH)/2),
    w: boardW, h: boardH, cell
  };
}
window.addEventListener('resize', resize);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸Ğ³Ñ€Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STATE = {
  RUN: 'run',
  PAUSE: 'pause',
  WIN: 'win',
  LOSE: 'lose',
};
let gameState = STATE.RUN;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ§Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ParticleSystem{
  constructor(){ this.ps = []; }
  burst(x,y,color, count=18){
    for(let i=0;i<count;i++){
      this.ps.push({
        x, y,
        vx: (rnd(-1,1))* (60 + 60*Math.random()),
        vy: (rnd(-1, -2)) * (60 + 60*Math.random()),
        life: .7 + Math.random()*.5,
        t: 0,
        size: 2 + Math.random()*3,
        color,
        rot: Math.random()*Math.PI,
        vr: rnd(-3,3),
      });
    }
  }
  update(dt){
    this.ps = this.ps.filter(p => (p.t += dt) < p.life);
    for(const p of this.ps){
      p.vy += 800 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.rot += p.vr * dt;
    }
  }
  draw(ctx){
    ctx.save();
    for(const p of this.ps){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }
}
const particles = new ParticleSystem();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ”Ğ¾ÑĞºĞ° (Ğ¼Ğ°Ñ‚Ñ‡â€‘3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Tile{
  constructor(type, r, c){
    this.id = uid();
    this.type = type;
    this.r = r; this.c = c;
    this.x = c; this.y = r; // Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸ (Ğ² ĞºĞ»ĞµÑ‚ĞºĞ°Ñ…)
    this.vy = 0;
    this.clearing = false;
    this.clearT = 0;
  }
}

class Board{
  constructor(rows, cols, types){
    this.rows = rows;
    this.cols = cols;
    this.types = types;
    this.grid = [];
    this.animating = false;
    this.selected = null; // {r,c}
    this.swapping = null; // Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°
    this.cascadeChain = 0;
    this.combo = 1;
    this.comboDecay = 0;
    this._initGrid();
  }

  _initGrid(){
    this.grid = Array.from({length:this.rows}, (_,r)=>
      Array.from({length:this.cols}, (_,c)=> new Tile(this._randTypeAvoid(r,c), r, c))
    );
    // Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ…Ğ¾Ğ´Ğ¾Ğ²
    if(!this.hasAnyMoves()){
      this.shuffle();
    }
  }
  _randType(){ return (Math.random()*this.types|0); }
  _randTypeAvoid(r,c){
    // Ğ¸Ğ·Ğ±ĞµĞ³Ğ°ĞµĞ¼ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹ 3+
    let t;
    do{
      t = this._randType();
    } while(
      (c>=2 && this.grid[r]?.[c-1]?.type===t && this.grid[r]?.[c-2]?.type===t) ||
      (r>=2 && this.grid[r-1]?.[c]?.type===t && this.grid[r-2]?.[c]?.type===t)
    );
    return t;
  }

  tileAt(r,c){ if(r<0||c<0||r>=this.rows||c>=this.cols) return null; return this.grid[r][c]; }

  *allTiles(){
    for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) yield this.grid[r][c];
  }

  draw(ctx){
    const {x:bx, y:by, cell} = boardRectPx;
    ctx.save();
    ctx.translate(bx, by);

    // Ñ„Ğ¾Ğ½ Ğ¿Ğ¾Ğ»Ñ
    drawBoardBack(ctx, this.rows, this.cols, cell);

    // ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ y Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ñ… Ğ¿ĞµÑ€ĞµĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¹ Ğ¿Ğ°Ğ´Ğ°ÑÑ‰Ğ¸Ñ… Ñ‚Ğ°Ğ¹Ğ»Ğ¾Ğ²
    const tiles = [...this.allTiles()].sort((a,b)=> (a.y - b.y) || (a.x - b.x));
    for(const t of tiles){
      drawGem(ctx, t, cell);
    }

    // Ğ¾Ğ±Ğ²Ğ¾Ğ´ĞºĞ°/Ñ€Ğ°Ğ¼ĞºĞ°
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = Math.max(1, cell*0.03);
    ctx.strokeRect(0,0, this.cols*cell, this.rows*cell);

    // Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ¹ ĞºĞ»ĞµÑ‚ĞºĞ¸
    if(this.selected){
      const {r,c} = this.selected;
      ctx.save();
      ctx.globalAlpha=.25;
      ctx.fillStyle = "#fff";
      ctx.fillRect(c*cell, r*cell, cell, cell);
      ctx.restore();
    }

    ctx.restore();
  }

  screenToCell(px, py){
    const {x:bx,y:by,cell,w,h} = boardRectPx;
    const c = Math.floor((px*DPR - bx) / cell);
    const r = Math.floor((py*DPR - by) / cell);
    if(r<0||c<0||r>=this.rows||c>=this.cols) return null;
    return {r,c};
  }

  pointerDown(cell){
    if(this.animating) return;
    this.selected = cell;
  }
  pointerMove(cell){
    if(this.animating || !this.selected || !cell) return;
    const dr = cell.r - this.selected.r;
    const dc = cell.c - this.selected.c;
    if(Math.abs(dr)+Math.abs(dc) === 1){
      this.trySwap(this.selected, cell);
      this.selected = null;
    }
  }
  pointerUp(cell){
    if(this.animating) return;
    this.selected = null;
  }

  trySwap(a,b){
    if(!a||!b) return;
    const ta = this.tileAt(a.r,a.c);
    const tb = this.tileAt(b.r,b.c);
    if(!ta||!tb) return;

    this.animating = true;
    const self = this;
    const swapAnim = {
      a:ta, b:tb,
      ax:ta.x, ay:ta.y,
      bx:tb.x, by:tb.y,
      t:0, done:false,
      duration: 1/CONFIG.swapSpeed
    };
    this.swapping = swapAnim;

    const commitSwap = ()=>{
      // Ğ¿Ğ¾Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ² ÑĞµÑ‚ĞºĞµ
      [this.grid[ta.r][ta.c], this.grid[tb.r][tb.c]] = [tb, ta];
      // Ğ¸ Ğ¸Ñ… Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹
      [ta.r, tb.r] = [tb.r, ta.r];
      [ta.c, tb.c] = [tb.c, ta.c];
      [ta.x, tb.x] = [tb.x, ta.x];
      [ta.y, tb.y] = [tb.y, ta.y];
    };

    // ÑÑ€Ğ°Ğ·Ñƒ Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸, Ğ° Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ ÑĞ´ĞµĞ»Ğ°ĞµĞ¼ Ğº Ğ½Ğ¾Ğ²Ñ‹Ğ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸ÑĞ¼
    commitSwap();

    // Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ
    const matches = this.findMatches();
    if(matches.length === 0){
      // Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ¸Ñ‚ÑŒ
      setTimeout(()=>{
        // swap back
        [this.grid[ta.r][ta.c], this.grid[tb.r][tb.c]] = [tb, ta];
        [ta.r, tb.r] = [tb.r, ta.r];
        [ta.c, tb.c] = [tb.c, ta.c];
        [ta.x, tb.x] = [tb.x, ta.x];
        [ta.y, tb.y] = [tb.y, ta.y];
        this.animating = false;
        this.swapping = null;
      }, 110); // Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ğ´Ğ°Ğ±Ğ»â€‘ĞºĞ»Ğ¸Ğºâ€‘Ñ„Ğ¸Ğ´Ğ±ĞµĞº
      return;
    }

    // ĞµÑÑ‚ÑŒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ â€” Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ĞºĞ°ÑĞºĞ°Ğ´
    this.cascadeChain = 0;
    this.resolveCascade(matches);
  }

  findMatches(){
    const matches = [];
    // Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ
    for(let r=0;r<this.rows;r++){
      let runType = null, runStart = 0, runLen = 0;
      for(let c=0;c<this.cols;c++){
        const t = this.grid[r][c];
        if(t.type === runType) runLen++;
        else{
          if(runLen>=3) matches.push({dir:'h', r, c0:runStart, c1:c-1, tiles: Array.from({length:runLen},(_,i)=>this.grid[r][runStart+i])});
          runType = t.type; runStart = c; runLen = 1;
        }
      }
      if(runLen>=3) matches.push({dir:'h', r, c0:runStart, c1:this.cols-1, tiles: Array.from({length:runLen},(_,i)=>this.grid[r][runStart+i])});
    }
    // Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ
    for(let c=0;c<this.cols;c++){
      let runType = null, runStart = 0, runLen = 0;
      for(let r=0;r<this.rows;r++){
        const t = this.grid[r][c];
        if(t.type === runType) runLen++;
        else{
          if(runLen>=3) matches.push({dir:'v', c, r0:runStart, r1:r-1, tiles: Array.from({length:runLen},(_,i)=>this.grid[runStart+i][c])});
          runType = t.type; runStart = r; runLen = 1;
        }
      }
      if(runLen>=3) matches.push({dir:'v', c, r0:runStart, r1:this.rows-1, tiles: Array.from({length:runLen},(_,i)=>this.grid[runStart+i][c])});
    }
    // ÑƒĞ½Ğ¸ĞºĞ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ°Ğ¹Ğ»Ñ‹
    const uniq = new Set();
    const result = [];
    for(const m of matches){
      const group = [];
      for(const t of m.tiles){
        if(!uniq.has(t.id)){ uniq.add(t.id); group.push(t); }
      }
      if(group.length>=3) result.push({dir:m.dir, tiles:group});
    }
    return result;
  }

  hasAnyMoves(){
    // Ğ¸Ñ‰ĞµĞ¼ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ğ¼ĞµĞ½, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ´Ğ°ÑÑ‚ Ğ¼Ğ°Ñ‚Ñ‡ (Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¾ÑĞµĞ´Ğ½Ğ¸Ñ… Ğ¿Ğ°Ñ€)
    for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){
      const t = this.grid[r][c];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){
        const r2=r+dr, c2=c+dc;
        if(r2<0||c2<0||r2>=this.rows||c2>=this.cols) continue;
        const u = this.grid[r2][c2];
        // swap virtually
        [t.type, u.type] = [u.type, t.type];
        const has = this._hasMatchAt(r,c) || this._hasMatchAt(r2,c2);
        [t.type, u.type] = [u.type, t.type];
        if(has) return true;
      }
    }
    return false;
  }
  _hasMatchAt(r,c){
    const t = this.grid[r][c]; const type = t.type;
    // Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒ
    let cnt=1, cc=c-1; while(cc>=0 && this.grid[r][cc].type===type) {cnt++;cc--;}
    cc=c+1; while(cc<this.cols && this.grid[r][cc].type===type) {cnt++;cc++;}
    if(cnt>=3) return true;
    // Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒ
    cnt=1; let rr=r-1; while(rr>=0 && this.grid[rr][c].type===type) {cnt++;rr--;}
    rr=r+1; while(rr<this.rows && this.grid[rr][c].type===type) {cnt++;rr++;}
    return cnt>=3;
  }

  shuffle(){
    // Ğ»Ñ‘Ğ³ĞºĞ°Ñ Ğ¿ĞµÑ€ĞµÑ‚Ğ°ÑĞ¾Ğ²ĞºĞ° Ğ´Ğ¾ Ñ‚ĞµÑ… Ğ¿Ğ¾Ñ€, Ğ¿Ğ¾ĞºĞ° ĞµÑÑ‚ÑŒ Ñ…Ğ¾Ğ´Ñ‹
    let flat = [...this.allTiles()];
    for(let i=flat.length-1;i>0;i--){
      const j = (Math.random()*(i+1)|0);
      [flat[i].type, flat[j].type] = [flat[j].type, flat[i].type];
    }
    if(!this.hasAnyMoves()) this.shuffle();
  }

  resolveCascade(initialMatches){
    const board = this;
    let wave = initialMatches;
    const loop = ()=>{
      if(!wave || wave.length===0){
        // ĞºĞ¾Ğ½ĞµÑ† ĞºĞ°ÑĞºĞ°Ğ´Ğ°
        board.animating = false;
        board.swapping = null;
        board.cascadeChain = 0;
        board.comboDecay = 2.5; // Ñ‡ĞµÑ€ĞµĞ· Ğ²Ñ€ĞµĞ¼Ñ ĞºĞ¾Ğ¼Ğ±Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾ Ğº x1
        return;
      }
      board.cascadeChain++;
      board.handleClear(wave);
      setTimeout(()=>{
        board.applyGravityAndSpawn(()=>{
          // ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº
          const next = board.findMatches();
          if(next.length>0) wave = next; else wave = null;
          loop();
        });
      }, 180);
    };
    loop();
  }

  handleClear(matches){
    const byColumn = new Set();
    let cleared = 0;
    for(const m of matches){
      for(const t of m.tiles){
        if(t.clearing) continue;
        t.clearing = true; t.clearT = 0;
        byColumn.add(t.c);
        cleared++;
        // Ñ‡Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹
        const {cell,x:bx,y:by} = boardRectPx;
        const cx = bx + (t.c+0.5)*cell;
        const cy = by + (t.r+0.5)*cell;
        particles.burst(cx, cy, gemColor(t.type, 0.9), 14);
      }
    }
    // Ğ¿Ğ¾Ğ²Ñ‹ÑĞ¸Ğ¼ ĞºĞ¾Ğ¼Ğ±Ğ¾
    this.combo = clamp(this.combo + .35, 1, CONFIG.maxComboMultiplier);
    document.getElementById('comboVal').textContent = "x"+this.combo.toFixed(1).replace(".0","");
    // ÑƒĞ¼ĞµĞ½ÑŒÑˆĞ°ĞµĞ¼ Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ
    const cascadeFactor = 1 + (this.cascadeChain-1)*CONFIG.cascadeBonus;
    const effectivePerTile = CONFIG.hazardPerTile * cascadeFactor * this.combo;
    hazard?.onTilesCleared(cleared, Array.from(byColumn), effectivePerTile);
  }

  applyGravityAndSpawn(done){
    const {rows, cols} = this;
    const fallPromises = [];
    // ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ ÑÑĞ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸: Ğ¿Ñ€ĞµĞ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ² "Ğ´Ñ‹Ñ€Ñ‹", Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ ÑĞ¼ĞµÑ‰Ğ°ĞµĞ¼
    for(let c=0;c<cols;c++){
      let writeRow = rows-1;
      for(let r=rows-1; r>=0; r--){
        const t = this.grid[r][c];
        if(t.clearing) continue;
        if(writeRow !== r){
          this.grid[writeRow][c] = t;
          t.r = writeRow;
          writeRow--;
        } else {
          writeRow--;
        }
      }
      // Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¼Ğ¸
      for(let r=writeRow; r>=0; r--){
        const nt = new Tile(this._randType(), r, c);
        nt.y = r - 8; // Ğ¿Ñ€Ğ¸Ğ»ĞµÑ‚ ÑĞ²ĞµÑ€Ñ…Ñƒ
        this.grid[r][c] = nt;
      }
    }

    // ĞĞ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ/ÑĞ¿Ğ°Ğ²Ğ½Ğ°
    const duration = 1/CONFIG.fallSpeed;
    const animTicks = 16; // ÑˆĞ°Ğ³Ğ¾Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ğ¿Ğ¾Ğ»ÑÑ†Ğ¸Ğ¸
    const perTick = duration/animTicks;

    let steps = 0;
    const fallTimer = setInterval(()=>{
      let any = false;
      for(const t of this.allTiles()){
        const ty = t.r;
        const dy = ty - t.y;
        if(Math.abs(dy) > 0.01){
          t.y = lerp(t.y, ty, .6);
          any = true;
        } else {
          t.y = ty;
        }
        if(t.clearing){
          t.clearT += perTick;
          if(t.clearT >= CONFIG.clearShrinkTime){
            // ÑƒĞ¶Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹
            t.clearing = false;
          }
        }
      }
      steps++;
      if(!any || steps>animTicks+6){
        clearInterval(fallTimer);
        done && done();
      }
    }, perTick*1000);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ ĞµĞ½Ğ´ĞµÑ€ ĞºĞ°Ğ¼Ğ½ĞµĞ¹ Ğ¸ Ğ¿Ğ¾Ğ»Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const gemHues = [8, 220, 120, 50, 280, 180]; // Ğ¾Ñ€Ğ°Ğ½Ğ¶, ÑĞ¸Ğ½Ğ¸Ğ¹, Ğ·ĞµĞ»Ñ‘Ğ½Ñ‹Ğ¹, Ğ¶Ñ‘Ğ»Ñ‚Ñ‹Ğ¹, Ñ„Ğ¸Ğ¾Ğ»ĞµÑ‚, Ğ±Ğ¸Ñ€ÑĞ·
function gemColor(type, a=1){
  const hue = gemHues[type % gemHues.length];
  return `hsla(${hue} 80% 55% / ${a})`;
}

function drawGem(ctx, t, cell){
  const px = (t.c + 0.5) * cell;
  const py = (t.y + 0.5) * cell;
  const baseSize = cell*0.82;
  const shrink = t.clearing ? (1 - clamp(t.clearT/CONFIG.clearShrinkTime, 0, 1)) : 1;
  const size = baseSize * shrink;

  ctx.save();
  ctx.translate(px, py);

  // Ñ‚ĞµĞ½ÑŒ
  ctx.shadowColor = "rgba(0,0,0,.45)";
  ctx.shadowBlur = cell*0.06;
  ctx.shadowOffsetY = cell*0.04;

  // ĞºĞ¾Ñ€Ğ¿ÑƒÑ â€” "Ğ´Ñ€Ğ°Ğ³Ğ¾Ñ†ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ¼ĞµĞ½ÑŒ" Ñ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ½Ğ¾Ğ¹ Ñ„Ğ°ÑĞºĞ¾Ğ¹
  const hue = gemHues[t.type % gemHues.length];
  const grad = ctx.createRadialGradient(-size*0.2, -size*0.25, size*0.1, 0,0, size*0.62);
  grad.addColorStop(0, `hsla(${hue} 85% 70% / 1)`);
  grad.addColorStop(1, `hsla(${hue} 80% 40% / 1)`);
  ctx.fillStyle = grad;

  // Ñ€Ğ¾Ğ¼Ğ±
  const s = size/2;
  ctx.beginPath();
  ctx.moveTo(0, -s);
  ctx.lineTo(s, 0);
  ctx.lineTo(0, s);
  ctx.lineTo(-s, 0);
  ctx.closePath();
  ctx.fill();

  // Ğ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ñ Ğ³Ñ€Ğ°Ğ½ÑŒ
  ctx.globalCompositeOperation = "lighter";
  ctx.fillStyle = "rgba(255,255,255,.25)";
  ctx.beginPath();
  ctx.moveTo(0, -s);
  ctx.lineTo(s*0.9, -s*0.08);
  ctx.lineTo(0, -s*0.2);
  ctx.closePath();
  ctx.fill();
  ctx.globalCompositeOperation = "source-over";

  // Ğ¾Ñ‚Ğ±Ğ»ĞµÑĞºâ€‘Ñ‚Ğ¾Ñ‡ĞºĞ°
  ctx.fillStyle = "rgba(255,255,255,.6)";
  ctx.beginPath();
  ctx.arc(-s*0.25, -s*0.25, s*0.10, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function drawBoardBack(ctx, rows, cols, cell){
  // Ğ¿Ğ»Ğ¸Ñ‚ĞºĞ°â€‘ÑĞµÑ‚Ğ¾Ñ‡ĞºĞ° Ñ Ğ»Ñ‘Ğ³ĞºĞ¸Ğ¼ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ¾Ğ¼
  const w = cols*cell, h = rows*cell;
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, "rgba(255,255,255,.05)");
  grad.addColorStop(1, "rgba(255,255,255,.02)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);

  ctx.save();
  ctx.globalAlpha=.25;
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.lineWidth = Math.max(1, cell*0.02);
  for(let r=1;r<rows;r++){
    const y=r*cell;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  for(let c=1;c<cols;c++){
    const x=c*cell;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }
  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸/ÑÑ†ĞµĞ½Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class HazardBase{
  constructor(){ this.level = .6; this.lossRate = CONFIG.baseHazardRise; this.state='run'; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.level += this.lossRate * dt;
    if(this.level>=1){ this.level=1; onLose(); }
  }
  reduce(amount){ this.level = clamp(this.level - amount, 0, 1); if(this.level<=0) onWin(); }
  onTilesCleared(count, columns, perTileEffective){ this.reduce(count * perTileEffective); }
  draw(ctx, w, h){}
  name(){ return "ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ"; }
}
class LavaHazard extends HazardBase{
  constructor(){ super(); this.bubbles=[]; this.drains=[]; this.waveT=0; }
  name(){ return "Ğ›Ğ°Ğ²Ğ°"; }
  onTilesCleared(count, columns, perTileEffective){
    // ÑƒÑĞ¸Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¿Ğ¾ ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ°Ğ¼, Ğ³Ğ´Ğµ Ğ±Ñ‹Ğ»Ğ¸ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ
    this.reduce(count * perTileEffective * 1.0);
    const now = performance.now();
    for(const c of columns){
      this.drains.push({ t: now, col: c, life: 1000 });
    }
  }
  update(dt){
    super.update(dt);
    this.waveT += dt;
    // Ğ¾Ñ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ²ÑˆĞ¸Ğµ Ğ´Ñ€ĞµĞ½Ğ°Ğ¶Ğ¸
    const now = performance.now();
    this.drains = this.drains.filter(d => now - d.t < d.life);
    // Ğ¿ÑƒĞ·Ñ‹Ñ€ÑŒĞºĞ¸
    if(Math.random()<.06){
      this.bubbles.push({
        x: rnd(0.05, 0.95), y: this.level - rnd(0.0, 0.1),
        r: rnd(2,5), t:0, life: rnd(.8,1.6)
      });
    }
    for(const b of this.bubbles){
      b.t += dt; b.y -= dt*.05; b.x += Math.sin(b.t*2)*.0008;
    }
    this.bubbles = this.bubbles.filter(b => b.t<b.life);
  }
  draw(ctx, w, h){
    // Ñ„Ğ¾Ğ½ Ğ·Ğ°Ğ¼ĞºĞ°
    drawBackdrop(ctx, w, h);

    // ĞºĞ¾Ñ€Ğ¾Ğ»ÑŒ Ğ½Ğ° Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğµ
    const platformY = h*0.22;
    drawKing(ctx, w*0.5, platformY, h*0.12);

    // ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ»Ğ°Ğ²Ñ‹ ÑĞ½Ğ¸Ğ·Ñƒ
    const lvlPix = h * this.level;
    const lavaTop = h - lvlPix;

    // Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸â€‘Ğ´Ñ€ĞµĞ½Ğ°Ğ¶Ğ¸ Ğ¸Ğ· ĞºĞ¾Ğ»Ğ¾Ğ½Ğ¾Ğº
    for(const d of this.drains){
      const x = (boardRectPx.x + (d.col+0.5)*boardRectPx.cell) / boardCanvas.width * w;
      drawDrainStream(ctx, x, lavaTop-6, 40, 0.9);
    }

    // Ñ‚ĞµĞºÑÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ»Ğ°Ğ²Ğ°
    drawLava(ctx, 0, lavaTop, w, h-lavaTop, this.waveT);

    // ÑˆĞºĞ°Ğ»Ğ° Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
    updateDangerUI(this.level);
  }
}

class DragonHazard extends HazardBase{
  constructor(){ super(); this.progress=.35; this.speed = .12; }
  name(){ return "Ğ”Ñ€Ğ°ĞºĞ¾Ğ½"; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.progress += this.speed*dt;
    this.level = clamp(this.progress, 0, 1);
    if(this.level>=1) onLose();
  }
  onTilesCleared(count, columns, perTileEffective){
    const push = count * perTileEffective * 0.9;
    this.progress = clamp(this.progress - push, 0, 1);
    this.level = this.progress;
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const y = h*0.22;
    drawKing(ctx, w*0.2, y, h*0.12);
    // Ğ´Ñ€Ğ°ĞºĞ¾Ğ½ ÑĞ»ĞµĞ²Ğ° Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ¾
    const x = lerp(-w*0.2, w*0.5, this.progress);
    drawDragon(ctx, x, y+20, h*0.18);
    updateDangerUI(this.level);
  }
}

class CeilingHazard extends HazardBase{
  constructor(){ super(); this.ceiling = .25; this.speed=.08; }
  name(){ return "ĞŸĞ¾Ñ‚Ğ¾Ğ»Ğ¾Ğº"; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.ceiling += this.speed*dt;
    this.level = clamp(this.ceiling, 0, .98);
    if(this.level>=.98) onLose();
  }
  onTilesCleared(count, columns, perTileEffective){
    const raise = count * perTileEffective * 1.1;
    this.ceiling = clamp(this.ceiling - raise, 0, .98);
    this.level = this.ceiling;
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const ceilY = h * this.ceiling;
    // Ğ¾Ğ¿ÑƒÑĞºĞ°ÑÑ‰Ğ°ÑÑÑ Ğ¿Ğ»Ğ¸Ñ‚Ğ°
    ctx.fillStyle = "rgba(200,205,230,.15)";
    ctx.fillRect(0, 0, w, ceilY);
    ctx.strokeStyle = "rgba(255,255,255,.25)";
    ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0,ceilY); ctx.lineTo(w,ceilY); ctx.stroke();
    drawKing(ctx, w*0.5, ceilY + h*0.12, h*0.12);
    updateDangerUI(this.level);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ/Ğ»Ğ°Ğ²Ñ‹/Ğ´Ñ€Ğ°ĞºĞ¾Ğ½Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBackdrop(ctx, w, h){
  // Ğ‘Ğ°ÑˆĞ½Ğ¸ Ğ¸ Ğ½ĞµĞ±Ğ¾
  const sky = ctx.createLinearGradient(0,0,0,h);
  sky.addColorStop(0, "#0e1226");
  sky.addColorStop(1, "#141833");
  ctx.fillStyle = sky; ctx.fillRect(0,0,w,h);

  // Ğ´Ğ°Ğ»Ñ‘ĞºĞ¸Ğµ Ğ³Ğ¾Ñ€Ñ‹/Ğ·Ğ°Ğ¼Ğ¾Ğº
  ctx.fillStyle = "rgba(255,255,255,.05)";
  const y0 = h*0.5;
  ctx.beginPath();
  ctx.moveTo(0, y0);
  for(let x=0;x<=w;x+=w/16){
    const y = y0 - Math.sin(x/w*Math.PI*2)*h*0.035 - h*0.02;
    ctx.lineTo(x,y);
  }
  ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath(); ctx.fill();

  // Ğ±Ğ°ÑˆĞ½Ğ¸
  const tower = (cx, top, sc)=>{
    ctx.save(); ctx.translate(cx, top); ctx.scale(sc, sc);
    ctx.fillStyle = "rgba(220,230,255,.10)";
    ctx.fillRect(-18, 0, 36, 120);
    ctx.fillRect(-26, -14, 52, 14);
    for(let i=-18;i<=18;i+=12){ ctx.fillRect(i-2, -24, 4, 10); }
    ctx.restore();
  };
  tower(w*0.18, h*0.18, 1.2);
  tower(w*0.82, h*0.22, 1.0);
}

function drawKing(ctx, x, y, size){
  ctx.save(); ctx.translate(x,y);

  // Ñ‚ĞµĞ½ÑŒ
  ctx.fillStyle = "rgba(0,0,0,.35)"; ctx.beginPath(); ctx.ellipse(0, size*.72, size*.66, size*.18, 0, 0, Math.PI*2); ctx.fill();

  // Ñ‚ĞµĞ»Ğ¾
  const robeGrad = ctx.createLinearGradient(0, -size*.1, 0, size*.6);
  robeGrad.addColorStop(0, "#3b3f8f"); robeGrad.addColorStop(1, "#23285f");
  ctx.fillStyle = robeGrad; roundRect(ctx, -size*.35, -size*.1, size*.7, size*.9, size*.2); ctx.fill();

  // Ğ²Ğ¾Ñ€Ğ¾Ñ‚Ğ½Ğ¸Ğº Ğ·Ğ¾Ğ»Ğ¾Ñ‚Ğ¾
  ctx.fillStyle = "#f0c862";
  roundRect(ctx, -size*.3, -size*.2, size*.6, size*.28, size*.12);
  ctx.fill();

  // Ğ»Ğ¸Ñ†Ğ¾
  ctx.fillStyle = "#f6d3b1"; roundRect(ctx, -size*.23, -size*.55, size*.46, size*.42, size*.12); ctx.fill();
  // Ğ³Ğ»Ğ°Ğ·Ğ°
  ctx.fillStyle = "#1b2048"; ctx.beginPath(); ctx.arc(-size*.08, -size*.42, size*.04, 0, Math.PI*2); ctx.arc(size*.08, -size*.42, size*.04, 0, Math.PI*2); ctx.fill();
  // ÑƒÑÑ‹
  ctx.strokeStyle = "#b98a60"; ctx.lineWidth = size*.045; ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(-size*.14, -size*.34); ctx.lineTo(-size*.02, -size*.34);
  ctx.moveTo(size*.02, -size*.34); ctx.lineTo(size*.14, -size*.34);
  ctx.stroke();

  // ĞºĞ¾Ñ€Ğ¾Ğ½Ğ°
  ctx.fillStyle = "#ffd166";
  ctx.beginPath();
  ctx.moveTo(-size*.20, -size*.60);
  ctx.lineTo(-size*.06, -size*.80);
  ctx.lineTo(0, -size*.62);
  ctx.lineTo(size*.06, -size*.80);
  ctx.lineTo(size*.20, -size*.60);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle="rgba(0,0,0,.2)"; ctx.lineWidth=1; ctx.stroke();

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawLava(ctx, x, y, w, h, t){
  // Ñ‚ĞµĞ»Ğ¾ Ğ»Ğ°Ğ²Ñ‹
  const lavaGrad = ctx.createLinearGradient(0, y, 0, y+h);
  lavaGrad.addColorStop(0, "rgba(255,120,80,.98)");
  lavaGrad.addColorStop(.6, "rgba(240,70,50,.98)");
  lavaGrad.addColorStop(1, "rgba(80,20,20,.98)");
  ctx.fillStyle = lavaGrad;
  ctx.fillRect(x, y, w, h);

  // Ğ²Ğ¾Ğ»Ğ½Ğ¸ÑÑ‚Ğ°Ñ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ…Ğ½Ğ¾ÑÑ‚ÑŒ
  ctx.save();
  ctx.globalAlpha = .9;
  ctx.fillStyle = "rgba(255,180,80,.9)";
  ctx.beginPath();
  const base = y+8;
  ctx.moveTo(0, base);
  for(let i=0;i<=w;i+=12){
    const wave = Math.sin((i*0.012 + t*4))*6 + Math.sin((i*0.022 - t*3))*4;
    ctx.lineTo(i, base + wave);
  }
  ctx.lineTo(w, y-40); ctx.lineTo(0, y-40); ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Ğ¿ÑƒĞ·Ñ‹Ñ€ÑŒĞºĞ¸
  ctx.save();
  for(const b of hazard.bubbles || []){
    const px = b.x*w, py = y + b.y*h;
    ctx.globalAlpha = 0.8*(1 - b.t/b.life);
    ctx.fillStyle = "rgba(255,230,200,.7)";
    ctx.beginPath(); ctx.arc(px, py, b.r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function drawDrainStream(ctx, x, y, len, alpha){
  ctx.save();
  const grad = ctx.createLinearGradient(0,y,0,y+len);
  grad.addColorStop(0, "rgba(255,220,140,"+alpha+")");
  grad.addColorStop(1, "rgba(255,120,60,0)");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x-3,y);
  ctx.lineTo(x+3,y);
  ctx.lineTo(x, y+len);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawDragon(ctx, x, y, size){
  ctx.save(); ctx.translate(x,y); ctx.scale(1,1);
  // Ñ‚ĞµĞ»Ğ¾
  ctx.fillStyle = "#6bd08f";
  roundRect(ctx, -size*.4, -size*.15, size*.8, size*.3, size*.15); ctx.fill();
  // Ñ…Ğ²Ğ¾ÑÑ‚
  ctx.beginPath(); ctx.moveTo(-size*.4, 0); ctx.quadraticCurveTo(-size*.65, -size*.2, -size*.8, 0); ctx.quadraticCurveTo(-size*.65, size*.18, -size*.4, 0); ctx.closePath(); ctx.fill();
  // ĞºÑ€Ñ‹Ğ»ÑŒÑ
  ctx.fillStyle="#4fb87a";
  ctx.beginPath(); ctx.moveTo(-size*.1, -size*.1); ctx.quadraticCurveTo(size*.1, -size*.5, size*.35, -size*.1); ctx.lineTo(size*.0, -size*.02); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-size*.2, size*.12); ctx.quadraticCurveTo(size*.0, -size*.35, size*.25, size*.12); ctx.lineTo(-size*.05, size*.18); ctx.closePath(); ctx.fill();
  // Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ°
  ctx.fillStyle="#6bd08f";
  roundRect(ctx, size*.25, -size*.12, size*.3, size*.18, size*.08); ctx.fill();
  // Ğ³Ğ»Ğ°Ğ·
  ctx.fillStyle="#1b2048";
  ctx.beginPath(); ctx.arc(size*.46, -size*.02, size*.022, 0, Math.PI*2); ctx.fill();
  // Ğ¾Ğ³Ğ¾Ğ½ÑŒ
  ctx.fillStyle = "orange";
  ctx.beginPath(); ctx.moveTo(size*.58, -size*.02); ctx.quadraticCurveTo(size*.7, -size*.16, size*.86, -size*.02);
  ctx.quadraticCurveTo(size*.7, size*.16, size*.58, -size*.02); ctx.closePath(); ctx.fill();
  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI/ĞĞ²ĞµÑ€Ğ»ĞµĞ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySub = document.getElementById('overlaySub');
const btnAgain = document.getElementById('btnAgain');
const btnContinue = document.getElementById('btnContinue');
const dangerFill = document.getElementById('dangerFill');
const comboPill = document.getElementById('comboPill');

function showOverlay(title, sub){
  overlayTitle.textContent = title;
  overlaySub.textContent = sub;
  overlay.classList.add('show');
}
function hideOverlay(){ overlay.classList.remove('show'); }

function updateDangerUI(level){
  dangerFill.style.width = (level*100).toFixed(1) + "%";
  // Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ñ‹
  const g = Math.max(0, 1 - level*1.2);
  const r = Math.min(1, level*1.2);
  dangerFill.style.background = `linear-gradient(90deg, rgba(${255*Math.min(1, r+.2)},${120*g},100,1), rgba(${255},${160*(1-g)},110,1))`;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ˜Ğ³Ñ€Ğ°: Ñ†Ğ¸ĞºĞ» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let board = null;
let hazard = null;
let lastT = performance.now();

function initGame(mode="lava"){
  board = new Board(CONFIG.rows, CONFIG.cols, CONFIG.tileTypes);
  hazard = (mode==="lava") ? new LavaHazard()
         : (mode==="dragon") ? new DragonHazard()
         : new CeilingHazard();
  gameState = STATE.RUN;
  hideOverlay();
  document.getElementById('comboVal').textContent = "x1";
  comboPill.querySelector('.dot').style.background = "var(--success)";
}

function onWin(){
  if(gameState!==STATE.RUN) return;
  gameState = STATE.WIN;
  comboPill.querySelector('.dot').style.background = "var(--success)";
  showOverlay("ĞŸĞ¾Ğ±ĞµĞ´Ğ°!", "ĞœĞ¾Ğ½Ğ°Ñ€Ñ… ÑĞ¿Ğ°ÑÑ‘Ğ½. Ğ¡Ñ‹Ğ³Ñ€Ğ°ĞµĞ¼ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¸Ğ»Ğ¸ ÑĞ¼ĞµĞ½Ğ¸Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼?");
}
function onLose(){
  if(gameState!==STATE.RUN) return;
  gameState = STATE.LOSE;
  comboPill.querySelector('.dot').style.background = "var(--danger)";
  showOverlay("ĞŸĞ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ", "ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ»Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ÑĞ½Ğ¾Ğ²Ğ°?");
}

function update(dt){
  if(gameState===STATE.PAUSE) return;
  hazard?.update(dt);

  // Ğ¿Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ·Ğ°Ñ‚ÑƒÑ…Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ±Ğ¾
  if(board.comboDecay>0){
    board.comboDecay -= dt;
    if(board.comboDecay<=0){
      board.combo = Math.max(1, board.combo - .2);
      document.getElementById('comboVal').textContent = "x"+board.combo.toFixed(1).replace(".0","");
      board.comboDecay = board.combo>1 ? 2.5 : 0;
    }
  }

  particles.update(dt);
}
function render(){
  // SCENE
  const w = sceneCanvas.width, h = sceneCanvas.height;
  sceneCtx.save(); sceneCtx.scale(DPR, DPR);
  // Ğ¾Ñ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´ CSSâ€‘Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ (Ğ¼Ñ‹ ÑƒĞ¶Ğµ Ğ² DPRâ€‘ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ñ…, Ñ‚Ğ¾Ğ³Ğ´Ğ° scale Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½). ĞĞ¾ Ğ¼Ñ‹ Ğ·Ğ°Ğ´Ğ°Ñ‘Ğ¼ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¸ĞºÑĞµĞ»Ğ¸ -> Ğ½Ğµ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼.
  sceneCtx.setTransform(1,0,0,1,0,0);
  // ĞšĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼: ĞºĞ°Ğ½Ğ²Ğ°Ñ ÑƒĞ¶Ğµ Ğ² DPRâ€‘Ğ¿Ğ¸ĞºÑĞµĞ»ÑÑ…, Ñ€Ğ¸ÑÑƒĞµĞ¼ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ
  hazard?.draw(sceneCtx, sceneCanvas.width, sceneCanvas.height);
  sceneCtx.restore();

  // BOARD
  boardCtx.clearRect(0,0, boardCanvas.width, boardCanvas.height);
  board.draw(boardCtx);

  // Ğ§Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ğ´Ğ¾ÑĞºĞ¸
  particles.draw(boardCtx);
}

function loop(now){
  const dt = Math.min(0.033, (now - lastT)/1000); lastT = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ’Ğ²Ğ¾Ğ´ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let pointerDown = false;
boardCanvas.addEventListener('pointerdown', (e)=>{
  if(gameState!==STATE.RUN) return;
  pointerDown = true;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if(cell) board.pointerDown(cell);
});
boardCanvas.addEventListener('pointermove', (e)=>{
  if(!pointerDown || gameState!==STATE.RUN) return;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if(cell) board.pointerMove(cell);
});
window.addEventListener('pointerup', (e)=>{
  if(!pointerDown) return; pointerDown=false;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  board.pointerUp(cell);
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btnRestart').addEventListener('click', ()=> initGame(document.getElementById('mode').value));
document.getElementById('btnPause').addEventListener('click', ()=>{
  if(gameState===STATE.RUN){ gameState=STATE.PAUSE; overlayTitle.textContent="ĞŸĞ°ÑƒĞ·Ğ°"; overlaySub.textContent="Ğ˜Ğ³Ñ€Ğ° Ğ½Ğ° Ğ¿Ğ°ÑƒĞ·Ğµ."; overlay.classList.add('show'); }
  else if(gameState===STATE.PAUSE){ gameState=STATE.RUN; overlay.classList.remove('show'); }
});
btnAgain.addEventListener('click', ()=>{ initGame(document.getElementById('mode').value); });
btnContinue.addEventListener('click', ()=>{ if(gameState===STATE.PAUSE){ gameState=STATE.RUN; } overlay.classList.remove('show'); });
document.getElementById('mode').addEventListener('change', e=> initGame(e.target.value));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ¡Ñ‚Ğ°Ñ€Ñ‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resize();
initGame("lava");
requestAnimationFrame(loop);

</script>
</body>
</html>
