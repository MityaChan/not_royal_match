<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>–°–ø–∞—Å–∏ –ú–æ–Ω–∞—Ä—Ö–∞ ‚Äî v2 (–ø–ª–∞–≤–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏, –∑–≤—É–∫)</title>
  <style>
    :root{
      --bg:#0f1222;
      --bg-panel:#171a33;
      --ink:#e6e8ff;
      --muted:#a9afd6;
      --accent:#7c9bff;
      --accent-2:#f6b76b;
      --danger:#ff5a7a;
      --success:#4ee1a0;
      --gold:#ffd166;
      --shadow:rgba(0,0,0,.35);
      --glass:rgba(255,255,255,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 80% -10%, #233 0%, rgba(0,0,0,0) 70%), radial-gradient(1400px 900px at 0% 0%, #19203b 0%, rgba(0,0,0,0) 70%), linear-gradient(180deg, #0b0e1a 0%, #10132a 100%);
      color:var(--ink);
      font: 15px/1.35 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      overflow:hidden;
      touch-action:none;
    }
    .wrap{
      height:100dvh;
      display:grid;
      grid-template-rows: 56px 1fr;
      gap:10px; padding:10px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px; padding:8px 10px;
      box-shadow: 0 12px 30px var(--shadow);
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .title{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px; text-shadow: 0 2px 8px rgba(0,0,0,.3); }
    .crown{
      width:28px; height:28px; display:inline-grid; place-items:center;
      background: radial-gradient(circle at 50% 30%, #fff7, #fff0), linear-gradient(180deg, #ffdf7e, #f0b030);
      box-shadow: inset 0 -2px 4px rgba(0,0,0,.2), 0 4px 10px rgba(0,0,0,.4);
      border-radius:6px;
      clip-path: polygon(8% 65%, 25% 35%, 35% 65%, 50% 28%, 64% 65%, 75% 35%, 92% 65%, 92% 86%, 8% 86%);
    }
    .controls{ display:flex; gap:8px; align-items:center; }
    .btn, .icon-btn{
      appearance:none; border:0; cursor:pointer; color:var(--ink);
      padding:8px 12px; border-radius:10px;
      background: linear-gradient(180deg, #2a2f59, #1b1f3b);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 2px 0 rgba(255,255,255,.08);
      font-weight:700;
    }
    .icon-btn{ width:40px; padding:8px; display:grid; place-items:center; }
    .btn:active,.icon-btn:active{ transform: translateY(1px) scale(.995); }
    .btn.secondary{ background: linear-gradient(180deg, #2a2b35, #1b1c29); }
    select{
      appearance:none; background: linear-gradient(180deg, #2a2f59, #1b1f3b);
      color:var(--ink); border-radius:10px; padding:8px 12px; border:1px solid rgba(255,255,255,.08);
      font-weight:700; box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 2px 0 rgba(255,255,255,.08);
    }
    .main{ display:grid; grid-template-rows: 1fr auto; gap:10px; min-height:0; }
    .panel{ position:relative; border-radius:18px; overflow:hidden; border:1px solid rgba(255,255,255,.08);
      background: radial-gradient(1600px 800px at 80% -10%, rgba(255,255,255,.06), rgba(255,255,255,.02)), linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.04));
      box-shadow: 0 20px 40px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.08); backdrop-filter: blur(10px); min-height:0;
    }
    .scene{ display:grid; grid-template-rows: 1fr; min-height:0; }
    .board{ display:grid; grid-template-rows: 1fr; min-height:300px; }
    canvas{ width:100%; height:100%; display:block; }
    .hud{ position:absolute; left:10px; right:10px; top:10px; display:flex; gap:8px; align-items:center; z-index:5; pointer-events:none; }
    .meter{ flex:1; height:14px; border-radius:999px; overflow:hidden; background: rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.12); box-shadow: inset 0 1px 2px rgba(0,0,0,.5); }
    .meter > .fill{ height:100%; width:40%; background: linear-gradient(90deg, #ff6f91, #ffa26f); box-shadow: 0 4px 12px rgba(255,100,120,.45); transition: width .25s ease-out; }
    .hud .pill{ pointer-events:auto; padding:6px 10px; border-radius:999px; background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(6px); font-weight:800; font-feature-settings: "tnum" 1; letter-spacing:.3px; display:flex; gap:6px; align-items:center; }
    .hud .pill .dot{ width:10px; height:10px; border-radius:999px; background: var(--success); box-shadow:0 0 12px var(--success); }
    .hud .pill.red .dot{ background: var(--danger); box-shadow:0 0 12px var(--danger); }
    .overlay{ position:absolute; inset:0; display:none; place-items:center; background: rgba(0,0,0,.55); z-index:10; }
    .overlay.show{ display:grid; }
    .dialog{ width:min(92%, 520px); border-radius:18px; padding:24px; background: linear-gradient(180deg, #1b1f3e, #12152a); border:1px solid rgba(255,255,255,.12); box-shadow: 0 30px 60px rgba(0,0,0,.6), inset 0 1px 0 rgba(255,255,255,.08); text-align:center; }
    .big{ font-size:26px; font-weight:900; margin:0 0 8px; letter-spacing:.4px; text-shadow: 0 4px 18px rgba(0,0,0,.5); }
    .sub{ color: var(--muted); margin-bottom:16px; }
    .dialog .actions{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
    .pill-btn{ cursor:pointer; padding:10px 16px; border-radius:999px; font-weight:800; border:0; background: linear-gradient(180deg, #2b2f59, #1c1f3b); color:var(--ink); border:1px solid rgba(255,255,255,.08); box-shadow: 0 10px 18px rgba(0,0,0,.45), inset 0 2px 0 rgba(255,255,255,.06); }
    .pill-btn:active{ transform: translateY(1px); }
    .pill-btn.gold{ background: linear-gradient(180deg, #ffd166, #d8a52e); color:#2c2100; }
    .legend{ position:absolute; right:10px; bottom:10px; left:10px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:center; z-index:3; pointer-events:none; }
    .tag{ pointer-events:auto; background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(6px); padding:6px 10px; border-radius:999px; font-weight:700; color:var(--muted); display:flex; gap:6px; align-items:center; }
    .tag .swatch{ width:12px; height:12px; border-radius:3px; }
    .tag strong{ color:var(--ink); }
    @media (min-aspect-ratio: 10/16){ .main{ grid-template-rows: 1fr min(52vh, 680px); } }
    @media (max-aspect-ratio: 10/16){ .main{ grid-template-rows: 1fr min(60vh, 760px); } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <div class="crown"></div>
        <div>–°–ü–ê–°–ò –ú–û–ù–ê–†–•–ê</div>
      </div>
      <div class="controls">
        <select id="mode">
          <option value="lava">üåã –†–µ–∂–∏–º: –õ–∞–≤–∞</option>
          <option value="dragon">üêâ –†–µ–∂–∏–º: –î—Ä–∞–∫–æ–Ω</option>
          <option value="ceiling">üß± –†–µ–∂–∏–º: –ü–æ—Ç–æ–ª–æ–∫</option>
        </select>
        <button class="btn" id="btnRestart">–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫</button>
        <button class="btn secondary" id="btnPause">–ü–∞—É–∑–∞</button>
        <button class="icon-btn" id="btnSound" title="–ó–≤—É–∫">üîä</button>
      </div>
    </header>

    <div class="main">
      <div class="panel scene">
        <div class="hud">
          <div class="pill" id="comboPill"><span class="dot"></span> –ö–æ–º–±–æ: <span id="comboVal">x1</span></div>
          <div class="meter"><div class="fill" id="dangerFill"></div></div>
          <div class="pill red">–û–ø–∞—Å–Ω–æ—Å—Ç—å</div>
        </div>
        <canvas id="scene"></canvas>
        <div class="legend">
          <div class="tag"><div class="swatch" style="background:#ff6f91"></div> <span>–°–±—Ä–æ—Å –æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∑–∞ —Ç–∞–π–ª</span> <strong>‚àí1</strong></div>
          <div class="tag"><div class="swatch" style="background:#4ee1a0"></div> <span>–ë–æ–Ω—É—Å –∫–∞—Å–∫–∞–¥–∞</span> <strong>+20%</strong></div>
          <div class="tag"><div class="swatch" style="background:#7c9bff"></div> <span>–ö–æ–º–±–æ‚Äë–º–Ω–æ–∂–∏—Ç–µ–ª—å</span> <strong>–¥–æ √ó5</strong></div>
        </div>
      </div>

      <div class="panel board">
        <canvas id="board"></canvas>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="dialog">
        <div class="big" id="overlayTitle">–ü–æ–±–µ–¥–∞!</div>
        <div class="sub" id="overlaySub">–ú–æ–Ω–∞—Ä—Ö —Å–ø–∞—Å—ë–Ω. –°—ã–≥—Ä–∞–µ–º –µ—â—ë?</div>
        <div class="actions">
          <button class="pill-btn gold" id="btnAgain">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
          <button class="pill-btn" id="btnContinue">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
        </div>
      </div>
    </div>
  </div>

<script>
/*  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    –°–ü–ê–°–ò –ú–û–ù–ê–†–•–ê ‚Äî v2: –ø–ª–∞–≤–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏, —É–ª—É—á—à—ë–Ω–Ω–∞—è –≥—Ä–∞—Ñ–∏–∫–∞, –º–µ–Ω—å—à–µ —Ü–≤–µ—Ç–æ–≤, –∑–≤—É–∫–∏.
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –£—Ç–∏–ª–∏—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a, b, t) => a + (b - a) * t;
const rnd = (a=1, b=0) => Math.random() * (a - b) + b;
const easeIn = t => t*t;
const easeOut = t => 1 - Math.pow(1 - t, 3);
const easeInOut = t => t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
let idCounter=1; const uid=()=>idCounter++;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CONFIG = {
  rows: 8,
  cols: 8,
  tileTypes: 5,             // –º–µ–Ω—å—à–µ —Ü–≤–µ—Ç–æ–≤ ‚Üí –ª–µ–≥—á–µ –Ω–∞—Ö–æ–¥–∏—Ç—å –º–∞—Ç—á
  gravity: 1600,
  swapTime: 0.25,           // –ü–õ–ê–í–ù–ï–ï: –≤—Ä–µ–º—è –æ–±–º–µ–Ω–∞
  clearTime: 0.34,          // –ü–õ–ê–í–ù–ï–ï: –≤—Ä–µ–º—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
  fallLambda: 16,           // –ü–õ–ê–í–ù–ï–ï: ¬´—É–ø—Ä—É–≥–æ—Å—Ç—å¬ª –ø–∞–¥–µ–Ω–∏—è (–±–æ–ª—å—à–µ ‚Äî –±—ã—Å—Ç—Ä–µ–µ)
  spawnRise: 9,             // –Ω–∞ —Å–∫–æ–ª—å–∫–æ –∫–ª–µ—Ç–æ–∫ –≤—ã—à–µ —Å–ø–∞–≤–Ω–∏–º
  spawnDelayPerRow: .02,
  baseHazardRise: .040,
  hazardPerTile: .012,
  cascadeBonus: .20,
  maxComboMultiplier: 5,
  shuffleIfNoMoves: true,
  portraitBoardScale: .94,
  sfx: true
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ö–∞–Ω–≤–∞—Å—ã –∏ —Ä–∞–∑–º–µ—Ä—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const sceneCanvas = document.getElementById('scene');
const boardCanvas = document.getElementById('board');
const sceneCtx = sceneCanvas.getContext('2d');
const boardCtx = boardCanvas.getContext('2d', { alpha: true });

let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
let boardRectPx = { x:0, y:0, w:0, h:0, cell: 0 };
let timeNow = 0;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const scenePanel = sceneCanvas.parentElement.getBoundingClientRect();
  const boardPanel = boardCanvas.parentElement.getBoundingClientRect();

  // SCENE
  sceneCanvas.width = Math.floor(scenePanel.width * DPR);
  sceneCanvas.height = Math.floor(scenePanel.height * DPR);
  sceneCanvas.style.width = scenePanel.width + "px";
  sceneCanvas.style.height = scenePanel.height + "px";

  // BOARD
  boardCanvas.width = Math.floor(boardPanel.width * DPR);
  boardCanvas.height = Math.floor(boardPanel.height * DPR);
  boardCanvas.style.width = boardPanel.width + "px";
  boardCanvas.style.height = boardPanel.height + "px";

  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ–ª—è
  const cols = CONFIG.cols, rows = CONFIG.rows;
  const padding = 16 * DPR;
  const usableW = boardCanvas.width - padding*2;
  const usableH = boardCanvas.height - padding*2;
  const cell = Math.floor(Math.min(usableW/cols, usableH/rows));
  const boardW = cell * cols;
  const boardH = cell * rows;
  boardRectPx = {
    x: Math.floor((boardCanvas.width - boardW)/2),
    y: Math.floor((boardCanvas.height - boardH)/2),
    w: boardW, h: boardH, cell
  };
}
window.addEventListener('resize', resize);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ó–≤—É–∫ (WebAudio) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Sound{
  constructor(){
    this.ctx = null;
    this.enabled = CONFIG.sfx;
    this.noiseBuf = null;
  }
  init(){
    if(this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    // –Ω–µ–±–æ–ª—å—à–æ–π —à—É–º–æ–≤–æ–π –±—É—Ñ–µ—Ä –¥–ª—è –≤–∑—Ä—ã–≤–æ–≤/–ø—É–∑—ã—Ä–µ–π
    const len = this.ctx.sampleRate * 0.2;
    const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<len;i++) data[i] = (Math.random()*2-1) * (1 - i/len);
    this.noiseBuf = buf;
  }
  _gain(value=0.2, t=this.ctx.currentTime){
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(value, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.15);
    return g;
  }
  pop(pitch=440, vol=0.25){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    o.type = "triangle";
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.2);
    o.frequency.setValueAtTime(pitch, t0);
    o.frequency.linearRampToValueAtTime(pitch*0.6, t0+0.2);
    o.connect(g).connect(this.ctx.destination);
    o.start(t0); o.stop(t0+0.22);
  }
  blipUp(){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    o.type = "sine";
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.15, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.18);
    o.frequency.setValueAtTime(220, t0);
    o.frequency.exponentialRampToValueAtTime(500, t0+0.18);
    o.connect(g).connect(this.ctx.destination);
    o.start(t0); o.stop(t0+0.2);
  }
  blipDown(){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    o.type = "sine";
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.12, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.22);
    o.frequency.setValueAtTime(500, t0);
    o.frequency.exponentialRampToValueAtTime(180, t0+0.22);
    o.connect(g).connect(this.ctx.destination);
    o.start(t0); o.stop(t0+0.24);
  }
  burstSparkles(count=1){
    if(!this.enabled || !this.ctx) return;
    for(let i=0;i<count;i++){
      const pitch = 650 + i*70 + Math.random()*30;
      this.pop(pitch, 0.18);
    }
  }
  noiseWhoosh(len=0.25, vol=0.2){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const src = this.ctx.createBufferSource();
    src.buffer = this.noiseBuf;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+len);
    const bp = this.ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 800;
    bp.Q.value = 0.6;
    src.connect(bp).connect(g).connect(this.ctx.destination);
    src.start(t0); src.stop(t0+len);
  }
  win(){
    if(!this.enabled || !this.ctx) return;
    this.burstSparkles(4);
    setTimeout(()=>this.pop(880,0.22), 120);
  }
  lose(){
    if(!this.enabled || !this.ctx) return;
    this.blipDown();
  }
}
const sound = new Sound();
const btnSound = document.getElementById('btnSound');
btnSound.addEventListener('click', ()=>{
  sound.enabled = !sound.enabled;
  btnSound.textContent = sound.enabled ? "üîä" : "üîà";
});
// –†–∞–∑—Ä–µ—à–∞–µ–º –∞—É–¥–∏–æ –ø–æ –ø–µ—Ä–≤–æ–º—É –¥–µ–π—Å—Ç–≤–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
const unlockAudio = ()=>{ try{ sound.init(); document.removeEventListener('pointerdown', unlockAudio); }catch(e){} };
document.addEventListener('pointerdown', unlockAudio, { once:true });

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –°–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const STATE = { RUN:'run', PAUSE:'pause', WIN:'win', LOSE:'lose' };
let gameState = STATE.RUN;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ß–∞—Å—Ç–∏—Ü—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class ParticleSystem{
  constructor(){ this.ps = []; }
  burst(x,y,color, count=18){
    for(let i=0;i<count;i++){
      this.ps.push({
        x, y,
        vx: (rnd(-1,1))* (60 + 60*Math.random()),
        vy: (rnd(-1, -2)) * (60 + 60*Math.random()),
        life: .7 + Math.random()*.5,
        t: 0,
        size: 2 + Math.random()*3,
        color,
        rot: Math.random()*Math.PI,
        vr: rnd(-3,3),
      });
    }
  }
  update(dt){
    this.ps = this.ps.filter(p => (p.t += dt) < p.life);
    for(const p of this.ps){
      p.vy += 800 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.rot += p.vr * dt;
    }
  }
  draw(ctx){
    ctx.save();
    for(const p of this.ps){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }
}
const particles = new ParticleSystem();

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –î–æ—Å–∫–∞ (–º–∞—Ç—á‚Äë3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Tile{
  constructor(type, r, c){
    this.id = uid();
    this.type = type;
    this.r = r; this.c = c;
    this.x = c; this.y = r; // –ø–æ–∑–∏—Ü–∏—è –≤ –∫–ª–µ—Ç–∫–∞—Ö (–¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏)
    this.clearing = false;
    this.clearT = 0;
    this.spawnPulse = 0; // –¥–ª—è –ª—ë–≥–∫–æ–≥–æ ¬´–≤–¥–æ—Ö‚Äë–≤—ã–¥–æ—Ö–∞¬ª
  }
}

class Board{
  constructor(rows, cols, types){
    this.rows = rows;
    this.cols = cols;
    this.types = types;
    this.grid = [];
    this.animating = false;
    this.selected = null;
    this.swapping = null; // {a,b, ax0,ay0,bx0,by0,t}
    this.cascadeChain = 0;
    this.combo = 1;
    this.comboDecay = 0;
    this.afterFall = null;
    this._initGrid();
  }
  _randType(){ return (Math.random()*this.types|0); }
  _wouldMatchWithType(r,c,t){
    const eq=(rr,cc)=> (rr>=0&&cc>=0&&rr<this.rows&&cc<this.cols && this.grid[rr][cc] && this.grid[rr][cc].type===t);
    // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
    if(eq(r,c-1)&&eq(r,c-2)) return true;
    if(eq(r,c-1)&&eq(r,c+1)) return true;
    if(eq(r,c+1)&&eq(r,c+2)) return true;
    // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
    if(eq(r-1,c)&&eq(r-2,c)) return true;
    if(eq(r-1,c)&&eq(r+1,c)) return true;
    if(eq(r+1,c)&&eq(r+2,c)) return true;
    return false;
  }
  _randTypeAvoidSpawn(r,c){
    let tries = 0;
    while(true){
      const t = this._randType();
      if(!this._wouldMatchWithType(r,c,t)) return t;
      if(++tries>20) return t; // —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞
    }
  }
  _randTypeAvoid(r,c){
    // –Ω–∞—á–∞–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è: –∏–∑–±–µ–≥–∞–µ–º 3 –ø–æ–¥—Ä—è–¥ –ø–æ –ª–µ–≤–æ–º—É/–≤–µ—Ä—Ö–Ω–µ–º—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
    let t, tries=0;
    do{
      t = this._randType();
      tries++;
    } while(
      (c>=2 && this.grid[r]?.[c-1]?.type===t && this.grid[r]?.[c-2]?.type===t) ||
      (r>=2 && this.grid[r-1]?.[c]?.type===t && this.grid[r-2]?.[c]?.type===t)
    && tries<30);
    return t;
  }
  _initGrid(){
    this.grid = Array.from({length:this.rows}, (_,r)=>
      Array.from({length:this.cols}, (_,c)=> new Tile(this._randTypeAvoid(r,c), r, c))
    );
    if(!this.hasAnyMoves()){
      this.shuffle();
    }
  }
  tileAt(r,c){ if(r<0||c<0||r>=this.rows||c>=this.cols) return null; return this.grid[r][c]; }
  *allTiles(){ for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) yield this.grid[r][c]; }

  update(dt){
    // –ø–ª–∞–≤–Ω–æ–µ –ø–æ–¥—Ç—è–≥–∏–≤–∞–Ω–∏–µ –∫ —Ü–µ–ª–µ–≤—ã–º –∫–ª–µ—Ç–∫–∞–º (–∏ –ø–∞–¥–µ–Ω–∏–µ, –∏ swap)
    if(this.swapping){
      const s = this.swapping;
      s.t = Math.min(1, s.t + dt/CONFIG.swapTime);
      const k = easeInOut(s.t);
      // –∏–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –ø—Ä—è–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã x/y –∫ —Ü–µ–ª—è–º
      s.a.x = lerp(s.ax0, s.ax1, k);
      s.a.y = lerp(s.ay0, s.ay1, k);
      s.b.x = lerp(s.bx0, s.bx1, k);
      s.b.y = lerp(s.by0, s.by1, k);
      if(s.t>=1){ this.swapping=null; }
    }
    let allSnapped = true;
    for(const t of this.allTiles()){
      // –ø–ª–∞–≤–Ω–æ–µ –ø–∞–¥–µ–Ω–∏–µ/–ø–æ–¥—Ç—è–≥–∏–≤–∞–Ω–∏–µ
      t.x = damp(t.x, t.c, CONFIG.fallLambda, dt);
      t.y = damp(t.y, t.r, CONFIG.fallLambda, dt);
      if(Math.abs(t.x - t.c) > 0.01 || Math.abs(t.y - t.r) > 0.01) allSnapped = false;

      // –∞–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
      if(t.clearing){
        t.clearT += dt;
      }
      // –ø—É–ª—å—Å –ø—Ä–∏ —Å–ø–∞–≤–Ω–µ
      if(t.spawnPulse>0){ t.spawnPulse = Math.max(0, t.spawnPulse - dt); }
    }
    if(this.animating && allSnapped && !this.swapping){
      this.animating = false;
      const cb = this.afterFall; this.afterFall = null;
      cb && cb();
    }
  }

  draw(ctx){
    const {x:bx, y:by, cell} = boardRectPx;
    ctx.save(); ctx.translate(bx, by);
    drawBoardBack(ctx, this.rows, this.cols, cell);
    const tiles = [...this.allTiles()].sort((a,b)=> (a.y - b.y) || (a.x - b.x));
    for(const t of tiles){ drawGem(ctx, t, cell); }
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = Math.max(1, cell*0.03);
    ctx.strokeRect(0,0, this.cols*cell, this.rows*cell);
    if(this.selected){
      const {r,c} = this.selected;
      ctx.save(); ctx.globalAlpha=.22; ctx.fillStyle = "#fff"; ctx.fillRect(c*cell, r*cell, cell, cell); ctx.restore();
    }
    ctx.restore();
  }

  screenToCell(px, py){
    const {x:bx,y:by,cell,w,h} = boardRectPx;
    const c = Math.floor((px*DPR - bx) / cell);
    const r = Math.floor((py*DPR - by) / cell);
    if(r<0||c<0||r>=this.rows||c>=this.cols) return null;
    return {r,c};
  }

  pointerDown(cell){ if(this.animating || this.swapping) return; this.selected = cell; }
  pointerMove(cell){
    if(this.animating || !this.selected || !cell) return;
    const dr = cell.r - this.selected.r;
    const dc = cell.c - this.selected.c;
    if(Math.abs(dr)+Math.abs(dc) === 1){
      this.trySwap(this.selected, cell);
      this.selected = null;
    }
  }
  pointerUp(){ if(this.animating) return; this.selected = null; }

  trySwap(a,b){
    if(!a||!b) return;
    const ta = this.tileAt(a.r,a.c);
    const tb = this.tileAt(b.r,b.c);
    if(!ta||!tb) return;

    // –ø–æ–¥–≥–æ—Ç–æ–≤–∏–º –∞–Ω–∏–º–∞—Ü–∏—é
    this.animating = true;
    const s = {
      a:ta, b:tb, t:0,
      ax0: ta.x, ay0: ta.y,
      bx0: tb.x, by0: tb.y,
      ax1: tb.c, ay1: tb.r,
      bx1: ta.c, by1: ta.r,
      revert:false
    };
    this.swapping = s;

    // –ª–æ–≥–∏—á–µ—Å–∫–∏ –ø–æ–º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
    [this.grid[ta.r][ta.c], this.grid[tb.r][tb.c]] = [tb, ta];
    [ta.r, tb.r] = [tb.r, ta.r];
    [ta.c, tb.c] = [tb.c, ta.c];

    // –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    const matches = this.findMatches();
    if(matches.length === 0){
      // –≤–æ–∑–≤—Ä–∞—Ç: –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º ¬´–±–∏–ø –≤–Ω–∏–∑¬ª
      sound.blipDown();
      // –æ—Ç–∫–∞—Ç –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω—ã –∞–Ω–∏–º–∞—Ü–∏–∏
      setTimeout(()=>{
        // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ª–æ–≥–∏—á–µ—Å–∫–∏
        [this.grid[ta.r][ta.c], this.grid[tb.r][tb.c]] = [tb, ta];
        [ta.r, tb.r] = [tb.r, ta.r];
        [ta.c, tb.c] = [tb.c, ta.c];
        // –∏ –∞–Ω–∏–º–∏—Ä—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ
        this.swapping = {
          a:ta, b:tb, t:0,
          ax0: ta.x, ay0: ta.y,
          bx0: tb.x, by0: tb.y,
          ax1: tb.c, ay1: tb.r,
          bx1: ta.c, by1: ta.r,
        };
        // –ø–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ ‚Äî —Å–Ω–∏–º–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
        setTimeout(()=>{ this.animating=false; this.swapping=null; }, CONFIG.swapTime*1000+20);
      }, CONFIG.swapTime*1000*0.6);
      return;
    }

    // —É–¥–∞—á–Ω—ã–π —Å–≤–æ–ø ‚Äî –ø—Ä–∏—è—Ç–Ω—ã–π –±–∏–ø –≤–≤–µ—Ä—Ö
    sound.blipUp();
    // –ó–∞–ø—É—Å–∫–∞–µ–º –∫–∞—Å–∫–∞–¥
    this.cascadeChain = 0;
    this.resolveCascade(matches);
  }

  findMatches(){
    const matches = [];
    // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
    for(let r=0;r<this.rows;r++){
      let runType = null, runStart = 0, runLen = 0;
      for(let c=0;c<this.cols;c++){
        const t = this.grid[r][c];
        if(t.type === runType) runLen++;
        else{
          if(runLen>=3) matches.push({dir:'h', tiles: Array.from({length:runLen},(_,i)=>this.grid[r][runStart+i])});
          runType = t.type; runStart = c; runLen = 1;
        }
      }
      if(runLen>=3) matches.push({dir:'h', tiles: Array.from({length:runLen},(_,i)=>this.grid[r][runStart+i])});
    }
    // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
    for(let c=0;c<this.cols;c++){
      let runType = null, runStart = 0, runLen = 0;
      for(let r=0;r<this.rows;r++){
        const t = this.grid[r][c];
        if(t.type === runType) runLen++;
        else{
          if(runLen>=3) matches.push({dir:'v', tiles: Array.from({length:runLen},(_,i)=>this.grid[runStart+i][c])});
          runType = t.type; runStart = r; runLen = 1;
        }
      }
      if(runLen>=3) matches.push({dir:'v', tiles: Array.from({length:runLen},(_,i)=>this.grid[runStart+i][c])});
    }
    // —É–Ω–∏–∫–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∞–π–ª—ã
    const uniq = new Set(), result = [];
    for(const m of matches){
      const group = [];
      for(const t of m.tiles){ if(!uniq.has(t.id)){ uniq.add(t.id); group.push(t); } }
      if(group.length>=3) result.push({dir:m.dir, tiles:group});
    }
    return result;
  }

  hasAnyMoves(){
    for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){
      const t = this.grid[r][c];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){
        const r2=r+dr, c2=c+dc;
        if(r2<0||c2<0||r2>=this.rows||c2>=this.cols) continue;
        const u = this.grid[r2][c2];
        [t.type, u.type] = [u.type, t.type];
        const has = this._hasMatchAt(r,c) || this._hasMatchAt(r2,c2);
        [t.type, u.type] = [u.type, t.type];
        if(has) return true;
      }
    }
    return false;
  }
  _hasMatchAt(r,c){
    const t = this.grid[r][c]; const type = t.type;
    let cnt=1, cc=c-1; while(cc>=0 && this.grid[r][cc].type===type) {cnt++;cc--;}
    cc=c+1; while(cc<this.cols && this.grid[r][cc].type===type) {cnt++;cc++;}
    if(cnt>=3) return true;
    cnt=1; let rr=r-1; while(rr>=0 && this.grid[rr][c].type===type) {cnt++;rr--;}
    rr=r+1; while(rr<this.rows && this.grid[rr][c].type===type) {cnt++;rr++;}
    return cnt>=3;
  }

  shuffle(){
    let flat = [...this.allTiles()];
    for(let i=flat.length-1;i>0;i--){
      const j = (Math.random()*(i+1)|0);
      [flat[i].type, flat[j].type] = [flat[j].type, flat[i].type];
    }
    if(!this.hasAnyMoves()) this.shuffle();
  }

  resolveCascade(initialMatches){
    let wave = initialMatches;
    const loop = ()=>{
      if(!wave || wave.length===0){
        this.animating = false;
        this.swapping = null;
        this.cascadeChain = 0;
        this.comboDecay = 2.5;
        return;
      }
      this.cascadeChain++;
      this.handleClear(wave);
      // —á—É—Ç—å –ø–æ–¥–æ–∂–¥—ë–º –Ω–∞ ¬´–ø–æ–ø¬ª
      setTimeout(()=>{
        this.applyGravityAndSpawn(()=>{
          const next = this.findMatches();
          if(next.length>0) { wave = next; loop(); }
          else { wave = null; loop(); }
        });
      }, 160);
    };
    loop();
  }

  handleClear(matches){
    const byColumn = new Set();
    let cleared = 0;
    for(const m of matches){
      for(const t of m.tiles){
        if(t.clearing) continue;
        t.clearing = true; t.clearT = 0;
        byColumn.add(t.c);
        cleared++;
        // —á–∞—Å—Ç–∏—Ü—ã
        const {cell,x:bx,y:by} = boardRectPx;
        const cx = bx + (t.c+0.5)*cell;
        const cy = by + (t.r+0.5)*cell;
        particles.burst(cx, cy, gemColor(t.type, 0.9), 16);
      }
    }
    // –∑–≤—É–∫–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è: –≤—ã—Å–æ—Ç–∞ –ø–æ–≤—ã—à–∞–µ—Ç—Å—è —Å –∫–∞—Å–∫–∞–¥–æ–º
    sound.burstSparkles(Math.min(4, Math.max(1, Math.round(this.cascadeChain))));
    // –∫–æ–º–±–æ
    this.combo = clamp(this.combo + .35, 1, CONFIG.maxComboMultiplier);
    document.getElementById('comboVal').textContent = "x"+this.combo.toFixed(1).replace(".0","");
    // —É–º–µ–Ω—å—à–∞–µ–º –æ–ø–∞—Å–Ω–æ—Å—Ç—å
    const cascadeFactor = 1 + (this.cascadeChain-1)*CONFIG.cascadeBonus;
    const effectivePerTile = CONFIG.hazardPerTile * cascadeFactor * this.combo;
    hazard?.onTilesCleared(cleared, Array.from(byColumn), effectivePerTile);
  }

  applyGravityAndSpawn(done){
    const {rows, cols} = this;
    // —Å–º–µ—â–∞–µ–º –≤–Ω–∏–∑
    for(let c=0;c<cols;c++){
      let writeRow = rows-1;
      for(let r=rows-1; r>=0; r--){
        const t = this.grid[r][c];
        if(t.clearing) continue;
        if(writeRow !== r){
          this.grid[writeRow][c] = t;
          t.r = writeRow; // —Ü–µ–ª–µ–≤–∞—è
          writeRow--;
        } else {
          writeRow--;
        }
      }
      // –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–æ–≤—ã–º–∏, –±–µ–∑ —Å–ø–∞–≤–Ω–∞ 3‚Äë–≤‚Äë—Ä—è–¥
      for(let r=writeRow; r>=0; r--){
        const type = this._randTypeAvoidSpawn(r,c);
        const nt = new Tile(type, r, c);
        nt.y = r - CONFIG.spawnRise; // –ø—Ä–∏–ª–µ—Ç —Å–≤–µ—Ä—Ö—É
        nt.spawnPulse = 0.35;
        this.grid[r][c] = nt;
      }
    }
    // –≤–∫–ª—é—á–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–∞–¥–µ–Ω–∏—è
    this.animating = true;
    this.afterFall = done;
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –†–µ–Ω–¥–µ—Ä –∫–∞–º–Ω–µ–π –∏ –ø–æ–ª—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const gemHues = [8, 220, 120, 50, 280]; // 5 —Ü–≤–µ—Ç–æ–≤
function gemColor(type, a=1){
  const hue = gemHues[type % gemHues.length];
  return `hsla(${hue} 80% 55% / ${a})`;
}

function drawGem(ctx, t, cell){
  const bob = 0.02*Math.sin((timeNow*1.2 + (t.r*7 + t.c*11))*0.8);
  const px = (t.x + 0.5) * cell;
  const py = (t.y + 0.5 + bob) * cell;
  let scale = 0.92 + 0.04*Math.sin((timeNow + t.id)*0.5); // –ª—ë–≥–∫–æ–µ –¥—ã—Ö–∞–Ω–∏–µ
  if(t.spawnPulse>0){ scale += 0.12 * easeOut(1 - t.spawnPulse/0.35); }

  // –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ —Å –∫—Ä–∞—Å–∏–≤—ã–º ¬´–ø—É—Ö¬ª
  let alpha = 1;
  if(t.clearing){
    const u = clamp(t.clearT / CONFIG.clearTime, 0, 1);
    if(u < 0.18) scale = lerp(scale, 1.15, u/0.18);
    else scale = lerp(1.15, 0.0, (u-0.18)/0.82);
    alpha = 1 - u;
  }

  const size = cell * scale;
  ctx.save();
  ctx.translate(px, py);
  ctx.globalAlpha = alpha;

  // —Ç–µ–Ω—å
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath(); ctx.ellipse(0, size*0.45, size*0.40, size*0.12, 0, 0, Math.PI*2); ctx.fill();

  // –º–Ω–æ–≥–æ–≥—Ä–∞–Ω–Ω–∏–∫ (–æ–∫—Ç–∞–≥–æ–Ω) —Å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –≥—Ä–∞–Ω—å—é –∏ –æ–±–≤–æ–¥–∫–æ–π
  const hue = gemHues[t.type % gemHues.length];
  const outer = size*0.48;
  const inner = size*0.30;
  // –∫–æ—Ä–ø—É—Å
  const grad = ctx.createRadialGradient(-outer*0.2, -outer*0.25, outer*0.1, 0,0, outer*0.85);
  grad.addColorStop(0, `hsla(${hue} 85% 68% / 1)`);
  grad.addColorStop(1, `hsla(${hue} 80% 38% / 1)`);
  ctx.fillStyle = grad;

  ctx.beginPath();
  for(let i=0;i<8;i++){
    const a = Math.PI/4 * i + Math.PI/8;
    const x = Math.cos(a)*outer, y = Math.sin(a)*outer;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.fill();

  // –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ–∞—Å–∫–∞
  ctx.fillStyle = `hsla(${hue} 90% 80% / .35)`;
  ctx.beginPath();
  for(let i=0;i<8;i++){
    const a = Math.PI/4 * i + Math.PI/8;
    const x = Math.cos(a)*inner, y = Math.sin(a)*inner;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.fill();

  // –±–ª–∏–∫–æ–≤–∞—è –≥—Ä–∞–Ω—å
  ctx.globalCompositeOperation = "lighter";
  const shine = ctx.createLinearGradient(-outer, -outer, outer, outer);
  shine.addColorStop(0, "rgba(255,255,255,.15)");
  shine.addColorStop(0.5, "rgba(255,255,255,0)");
  ctx.fillStyle = shine;
  ctx.beginPath();
  ctx.moveTo(-outer*0.8, -outer*0.2);
  ctx.lineTo(outer*0.2, -outer*0.8);
  ctx.lineTo(outer*0.6, -outer*0.4);
  ctx.lineTo(-outer*0.4, outer*0.6);
  ctx.closePath();
  ctx.fill();
  ctx.globalCompositeOperation = "source-over";

  // –∫–æ–Ω—Ç—É—Ä
  ctx.strokeStyle = "rgba(0,0,0,.35)";
  ctx.lineWidth = Math.max(1, cell*0.03);
  ctx.stroke();

  // –º–∞–ª–µ–Ω—å–∫–∞—è –∏—Å–∫–æ—Ä–∫–∞
  ctx.fillStyle = "rgba(255,255,255,.7)";
  ctx.beginPath();
  ctx.arc(-outer*0.25, -outer*0.25, outer*0.09, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function drawBoardBack(ctx, rows, cols, cell){
  const w = cols*cell, h = rows*cell;
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, "rgba(255,255,255,.05)");
  grad.addColorStop(1, "rgba(255,255,255,.02)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);
  ctx.save();
  ctx.globalAlpha=.22;
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.lineWidth = Math.max(1, cell*0.02);
  for(let r=1;r<rows;r++){ const y=r*cell; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  for(let c=1;c<cols;c++){ const x=c*cell; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–ø–∞—Å–Ω–æ—Å—Ç–∏/—Å—Ü–µ–Ω—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class HazardBase{
  constructor(){ this.level = .55; this.lossRate = CONFIG.baseHazardRise; this.state='run'; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.level += this.lossRate * dt;
    if(this.level>=1){ this.level=1; onLose(); }
  }
  reduce(amount){ this.level = clamp(this.level - amount, 0, 1); if(this.level<=0) onWin(); }
  onTilesCleared(count, columns, perTileEffective){ this.reduce(count * perTileEffective); }
  draw(ctx, w, h){}
  name(){ return "–û–ø–∞—Å–Ω–æ—Å—Ç—å"; }
}
class LavaHazard extends HazardBase{
  constructor(){ super(); this.bubbles=[]; this.drains=[]; this.waveT=0; }
  name(){ return "–õ–∞–≤–∞"; }
  onTilesCleared(count, columns, perTileEffective){
    this.reduce(count * perTileEffective * 1.0);
    const now = performance.now();
    for(const c of columns){ this.drains.push({ t: now, col: c, life: 1000 }); }
    sound.noiseWhoosh(0.2, 0.12);
  }
  update(dt){
    super.update(dt);
    this.waveT += dt;
    const now = performance.now();
    this.drains = this.drains.filter(d => now - d.t < d.life);
    if(Math.random()<.06){
      this.bubbles.push({ x: rnd(0.05, 0.95), y: this.level - rnd(0.0, 0.1), r: rnd(2,5), t:0, life: rnd(.8,1.6) });
    }
    for(const b of this.bubbles){ b.t += dt; b.y -= dt*.05; b.x += Math.sin(b.t*2)*.0008; }
    this.bubbles = this.bubbles.filter(b => b.t<b.life);
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const platformY = h*0.22;
    drawKing(ctx, w*0.5, platformY, h*0.13);
    const lvlPix = h * this.level;
    const lavaTop = h - lvlPix;
    for(const d of this.drains){
      const x = (boardRectPx.x + (d.col+0.5)*boardRectPx.cell) / boardCanvas.width * w;
      drawDrainStream(ctx, x, lavaTop-6, 42, 0.9);
    }
    drawLava(ctx, 0, lavaTop, w, h-lavaTop, this.waveT);
    updateDangerUI(this.level);
  }
}
class DragonHazard extends HazardBase{
  constructor(){ super(); this.progress=.35; this.speed = .12; }
  name(){ return "–î—Ä–∞–∫–æ–Ω"; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.progress += this.speed*dt;
    this.level = clamp(this.progress, 0, 1);
    if(this.level>=1) onLose();
  }
  onTilesCleared(count, columns, perTileEffective){
    const push = count * perTileEffective * 0.9;
    this.progress = clamp(this.progress - push, 0, 1);
    this.level = this.progress;
    sound.noiseWhoosh(0.15, 0.1);
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const y = h*0.24;
    drawKing(ctx, w*0.18, y, h*0.13);
    const x = lerp(-w*0.2, w*0.48, this.progress);
    drawDragon(ctx, x, y+18, h*0.19);
    updateDangerUI(this.level);
  }
}
class CeilingHazard extends HazardBase{
  constructor(){ super(); this.ceiling = .25; this.speed=.08; }
  name(){ return "–ü–æ—Ç–æ–ª–æ–∫"; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.ceiling += this.speed*dt;
    this.level = clamp(this.ceiling, 0, .98);
    if(this.level>=.98) onLose();
  }
  onTilesCleared(count, columns, perTileEffective){
    const raise = count * perTileEffective * 1.1;
    this.ceiling = clamp(this.ceiling - raise, 0, .98);
    this.level = this.ceiling;
    sound.noiseWhoosh(0.15, 0.1);
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const ceilY = h * this.ceiling;
    ctx.fillStyle = "rgba(200,205,230,.18)";
    ctx.fillRect(0, 0, w, ceilY);
    ctx.strokeStyle = "rgba(255,255,255,.25)";
    ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0,ceilY); ctx.lineTo(w,ceilY); ctx.stroke();
    drawKing(ctx, w*0.5, ceilY + h*0.12, h*0.13);
    updateDangerUI(this.level);
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –†–∏—Å–æ–≤–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã (—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–µ–µ) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawBackdrop(ctx, w, h){
  // –ù–µ–±–æ —Å–æ –∑–≤—ë–∑–¥–∞–º–∏ –∏ –ª—É–Ω–æ–π
  const sky = ctx.createLinearGradient(0,0,0,h);
  sky.addColorStop(0, "#0b0f23");
  sky.addColorStop(1, "#151a37");
  ctx.fillStyle = sky; ctx.fillRect(0,0,w,h);

  // –∑–≤—ë–∑–¥—ã
  ctx.save();
  ctx.globalAlpha = 0.6;
  for(let i=0;i<120;i++){
    const x = (i*97 % w), y = (i*i*29 % h*0.6);
    const r = (i%7===0) ? 2 : 1;
    ctx.fillStyle = "rgba(255,255,255,.8)";
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // –ª—É–Ω–∞
  ctx.save();
  const moonX = w*0.86, moonY = h*0.15, mr = Math.min(w,h)*0.04;
  const mg = ctx.createRadialGradient(moonX, moonY, mr*0.2, moonX, moonY, mr);
  mg.addColorStop(0, "rgba(255,255,240,1)");
  mg.addColorStop(1, "rgba(255,255,240,0)");
  ctx.fillStyle = mg; ctx.beginPath(); ctx.arc(moonX, moonY, mr, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // –¥–∞–ª—ë–∫–∏–µ –≥–æ—Ä—ã
  ctx.fillStyle = "rgba(200,220,255,.06)";
  const y0 = h*0.58;
  ctx.beginPath(); ctx.moveTo(0,y0);
  for(let x=0;x<=w;x+=w/16){ const y = y0 - Math.sin(x/w*Math.PI*2)*h*0.035 - h*0.02; ctx.lineTo(x,y); }
  ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath(); ctx.fill();

  // –∑–∞–º–æ–∫/–±–∞—à–Ω–∏ —Å –ª—ë–≥–∫–æ–π –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–µ–π
  const tower = (cx, top, sc)=>{
    ctx.save(); ctx.translate(cx, top); ctx.scale(sc, sc);
    // –æ—Å–Ω–æ–≤–∞–Ω–∏–µ
    const grad = ctx.createLinearGradient(0,0,0,120);
    grad.addColorStop(0, "rgba(210,220,255,.16)");
    grad.addColorStop(1, "rgba(180,190,230,.08)");
    ctx.fillStyle = grad; roundRect(ctx, -18, 0, 36, 120, 4); ctx.fill();
    // –∑—É–±—Ü—ã
    ctx.fillStyle = "rgba(220,230,255,.16)";
    roundRect(ctx, -26, -14, 52, 14, 4); ctx.fill();
    for(let i=-18;i<=18;i+=12){ roundRect(ctx, i-3, -24, 6, 10, 2); ctx.fill(); }
    // —Ç–µ–∫—Å—Ç—É—Ä–∞ –∫–∏—Ä–ø–∏—á–µ–π
    ctx.strokeStyle = "rgba(255,255,255,.06)"; ctx.lineWidth = 1;
    for(let y=10;y<110;y+=10){ ctx.beginPath(); ctx.moveTo(-18,y); ctx.lineTo(18,y); ctx.stroke(); }
    ctx.restore();
  };
  tower(w*0.18, h*0.18, 1.2);
  tower(w*0.82, h*0.22, 1.05);
}

function drawKing(ctx, x, y, size){
  ctx.save(); ctx.translate(x,y);

  // —Ç–µ–Ω—å
  ctx.fillStyle = "rgba(0,0,0,.38)"; ctx.beginPath(); ctx.ellipse(0, size*.72, size*.66, size*.18, 0, 0, Math.PI*2); ctx.fill();

  // –ø–ª–∞—â
  const robeGrad = ctx.createLinearGradient(0, -size*.1, 0, size*.6);
  robeGrad.addColorStop(0, "#40489d"); robeGrad.addColorStop(1, "#242a66");
  ctx.fillStyle = robeGrad; roundRect(ctx, -size*.38, -size*.05, size*.76, size*.95, size*.22); ctx.fill();

  // –º–µ—Ö–æ–≤–∞—è –æ–ø—É—à–∫–∞
  ctx.fillStyle = "#e6e7ef"; roundRect(ctx, -size*.38, -size*.2, size*.76, size*.22, size*.12); ctx.fill();
  ctx.fillStyle = "#d1d3df"; roundRect(ctx, -size*.35, -size*.18, size*.70, size*.18, size*.10); ctx.fill();

  // –ª–∏—Ü–æ
  const faceGrad = ctx.createLinearGradient(0, -size*.6, 0, -size*.1);
  faceGrad.addColorStop(0, "#f9dbbd"); faceGrad.addColorStop(1, "#eec6a2");
  ctx.fillStyle = faceGrad; roundRect(ctx, -size*.23, -size*.55, size*.46, size*.42, size*.12); ctx.fill();

  // –Ω–æ—Å, –≥–ª–∞–∑–∞, –±—Ä–æ–≤–∏
  ctx.fillStyle = "#1b2048";
  ctx.beginPath(); ctx.arc(-size*.08, -size*.40, size*.035, 0, Math.PI*2); ctx.arc(size*.08, -size*.40, size*.035, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = "#1b2048"; ctx.lineWidth = size*.02; ctx.lineCap="round";
  ctx.beginPath(); ctx.moveTo(-size*.12, -size*.46); ctx.lineTo(-size*.02, -size*.46); ctx.moveTo(size*.02, -size*.46); ctx.lineTo(size*.12, -size*.46); ctx.stroke();
  ctx.fillStyle = "#e4b995"; roundRect(ctx, -size*.03, -size*.40, size*.06, size*.12, size*.03); ctx.fill();

  // —É—Å—ã –∏ –±–æ—Ä–æ–¥–∞
  ctx.strokeStyle = "#c2986a"; ctx.lineWidth = size*.045; ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(-size*.14, -size*.30); ctx.lineTo(-size*.02, -size*.30);
  ctx.moveTo(size*.02, -size*.30); ctx.lineTo(size*.14, -size*.30); ctx.stroke();
  ctx.fillStyle = "#b78b63"; roundRect(ctx, -size*.16, -size*.25, size*.32, size*.10, size*.04); ctx.fill();

  // –∫–æ—Ä–æ–Ω–∞ —Å –¥—Ä–∞–≥–æ—Ü–µ–Ω–Ω–æ—Å—Ç—è–º–∏
  ctx.fillStyle = "#ffd166";
  ctx.beginPath();
  ctx.moveTo(-size*.22, -size*.60);
  ctx.lineTo(-size*.08, -size*.84);
  ctx.lineTo(0, -size*.62);
  ctx.lineTo(size*.08, -size*.84);
  ctx.lineTo(size*.22, -size*.60);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle="rgba(0,0,0,.25)"; ctx.lineWidth=1.2; ctx.stroke();
  ctx.fillStyle="#8bd5ff"; ctx.beginPath(); ctx.arc(-size*.1, -size*.65, size*.035, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle="#ff8bc1"; ctx.beginPath(); ctx.arc(size*.1, -size*.65, size*.035, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawLava(ctx, x, y, w, h, t){
  const lavaGrad = ctx.createLinearGradient(0, y, 0, y+h);
  lavaGrad.addColorStop(0, "rgba(255,160,100,.98)");
  lavaGrad.addColorStop(.6, "rgba(240,90,60,.98)");
  lavaGrad.addColorStop(1, "rgba(80,20,20,.98)");
  ctx.fillStyle = lavaGrad; ctx.fillRect(x, y, w, h);
  // –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
  ctx.save(); ctx.globalAlpha = .9; ctx.fillStyle = "rgba(255,210,120,.9)";
  ctx.beginPath();
  const base = y+8; ctx.moveTo(0, base);
  for(let i=0;i<=w;i+=12){ const wave = Math.sin((i*0.012 + t*4))*6 + Math.sin((i*0.022 - t*3))*4; ctx.lineTo(i, base + wave); }
  ctx.lineTo(w, y-40); ctx.lineTo(0, y-40); ctx.closePath(); ctx.fill(); ctx.restore();
  // –ø—É–∑—ã—Ä—å–∫–∏
  ctx.save();
  for(const b of hazard.bubbles || []){
    const px = b.x*w, py = y + b.y*h;
    ctx.globalAlpha = 0.8*(1 - b.t/b.life);
    ctx.fillStyle = "rgba(255,230,200,.7)";
    ctx.beginPath(); ctx.arc(px, py, b.r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}
function drawDrainStream(ctx, x, y, len, alpha){
  ctx.save();
  const grad = ctx.createLinearGradient(0,y,0,y+len);
  grad.addColorStop(0, "rgba(255,220,140,"+alpha+")");
  grad.addColorStop(1, "rgba(255,120,60,0)");
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.moveTo(x-3,y); ctx.lineTo(x+3,y); ctx.lineTo(x, y+len); ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawDragon(ctx, x, y, size){
  ctx.save(); ctx.translate(x,y);
  // —Ç–µ–Ω—å
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath(); ctx.ellipse(0, size*0.6, size*0.7, size*0.18, 0, 0, Math.PI*2); ctx.fill();

  // —Ç–µ–ª–æ
  const bodyGrad = ctx.createLinearGradient(-size*.4, 0, size*.4, 0);
  bodyGrad.addColorStop(0, "#5ec184"); bodyGrad.addColorStop(1, "#3aa967");
  ctx.fillStyle = bodyGrad; roundRect(ctx, -size*.45, -size*.18, size*.9, size*.36, size*.18); ctx.fill();

  // –∂–∏–≤–æ—Ç (—Å–≤–µ—Ç–ª–µ–µ)
  ctx.fillStyle = "#82d9a4";
  roundRect(ctx, -size*.25, -size*.10, size*.5, size*.22, size*.10); ctx.fill();

  // —Ö–≤–æ—Å—Ç
  ctx.fillStyle = "#46b275";
  ctx.beginPath(); ctx.moveTo(-size*.45, 0); ctx.quadraticCurveTo(-size*.75, -size*.2, -size*.9, 0); ctx.quadraticCurveTo(-size*.7, size*.2, -size*.45, 0); ctx.closePath(); ctx.fill();

  // –∫—Ä—ã–ª—å—è
  ctx.fillStyle="#3aa967";
  ctx.beginPath(); ctx.moveTo(-size*.1, -size*.12); ctx.quadraticCurveTo(size*.1, -size*.55, size*.35, -size*.12); ctx.lineTo(size*.0, -size*.02); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-size*.2, size*.12); ctx.quadraticCurveTo(size*.0, -size*.38, size*.25, size*.12); ctx.lineTo(-size*.05, size*.18); ctx.closePath(); ctx.fill();

  // –≥–æ–ª–æ–≤–∞
  roundRect(ctx, size*.28, -size*.14, size*.34, size*.20, size*.08); ctx.fill();
  // –∂–∏–≤–æ—Ç–∏–∫ –≥–æ–ª–æ–≤—ã
  ctx.fillStyle="#82d9a4"; roundRect(ctx, size*.28, -size*.05, size*.26, size*.10, size*.05); ctx.fill();

  // —Ä–æ–≥ –∏ —á–µ–ª—é—Å—Ç—å
  ctx.fillStyle="#72d39a";
  ctx.beginPath(); ctx.moveTo(size*.44, -size*.22); ctx.lineTo(size*.52, -size*.32); ctx.lineTo(size*.48, -size*.18); ctx.closePath(); ctx.fill();
  ctx.fillStyle="#5ec184";
  ctx.beginPath(); ctx.moveTo(size*.62, -size*.02); ctx.lineTo(size*.78, -size*.08); ctx.lineTo(size*.62, size*.06); ctx.closePath(); ctx.fill();

  // –≥–ª–∞–∑
  ctx.fillStyle="#1b2048"; ctx.beginPath(); ctx.arc(size*.52, -size*.02, size*.022, 0, Math.PI*2); ctx.fill();

  // –æ–≥–æ–Ω—å
  const fg = ctx.createRadialGradient(size*.86, -size*.02, size*.02, size*.86, -size*.02, size*.22);
  fg.addColorStop(0, "rgba(255,240,200,1)");
  fg.addColorStop(1, "rgba(255,120,0,0.0)");
  ctx.fillStyle = fg;
  ctx.beginPath();
  ctx.moveTo(size*.58, -size*.02);
  ctx.quadraticCurveTo(size*.7, -size*.16, size*.86, -size*.02);
  ctx.quadraticCurveTo(size*.7, size*.16, size*.58, -size*.02);
  ctx.closePath(); ctx.fill();

  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UI/–û–≤–µ—Ä–ª–µ–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySub = document.getElementById('overlaySub');
const btnAgain = document.getElementById('btnAgain');
const btnContinue = document.getElementById('btnContinue');
const dangerFill = document.getElementById('dangerFill');
const comboPill = document.getElementById('comboPill');

function showOverlay(title, sub){ overlayTitle.textContent = title; overlaySub.textContent = sub; overlay.classList.add('show'); }
function hideOverlay(){ overlay.classList.remove('show'); }

function updateDangerUI(level){
  dangerFill.style.width = (level*100).toFixed(1) + "%";
  const g = Math.max(0, 1 - level*1.2);
  const r = Math.min(1, level*1.2);
  dangerFill.style.background = `linear-gradient(90deg, rgba(${255*Math.min(1, r+.2)},${120*g},100,1), rgba(${255},${160*(1-g)},110,1))`;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ò–≥—Ä–∞: —Ü–∏–∫–ª ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let board = null;
let hazard = null;
let lastT = performance.now();

function initGame(mode="lava"){
  board = new Board(CONFIG.rows, CONFIG.cols, CONFIG.tileTypes);
  hazard = (mode==="lava") ? new LavaHazard() : (mode==="dragon") ? new DragonHazard() : new CeilingHazard();
  gameState = STATE.RUN;
  hideOverlay();
  document.getElementById('comboVal').textContent = "x1";
  comboPill.querySelector('.dot').style.background = "var(--success)";
}
function onWin(){ if(gameState!==STATE.RUN) return; gameState=STATE.WIN; comboPill.querySelector('.dot').style.background="var(--success)"; showOverlay("–ü–æ–±–µ–¥–∞!", "–ú–æ–Ω–∞—Ä—Ö —Å–ø–∞—Å—ë–Ω. –°—ã–≥—Ä–∞–µ–º –µ—â—ë —Ä–∞–∑ –∏–ª–∏ —Å–º–µ–Ω–∏–º —Ä–µ–∂–∏–º?"); sound.win(); }
function onLose(){ if(gameState!==STATE.RUN) return; gameState=STATE.LOSE; comboPill.querySelector('.dot').style.background="var(--danger)"; showOverlay("–ü–æ—Ä–∞–∂–µ–Ω–∏–µ", "–û–ø–∞—Å–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥–∏–ª–∞. –ü–æ–ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞?"); sound.lose(); }

function update(dt){
  if(gameState===STATE.PAUSE) return;
  hazard?.update(dt);
  board?.update(dt);
  // –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –∫–æ–º–±–æ
  if(board.comboDecay>0){ board.comboDecay -= dt; if(board.comboDecay<=0){ board.combo = Math.max(1, board.combo - .2); document.getElementById('comboVal').textContent = "x"+board.combo.toFixed(1).replace(".0",""); board.comboDecay = board.combo>1 ? 2.5 : 0; } }
  particles.update(dt);
}
function render(){
  // SCENE
  hazard?.draw(sceneCtx, sceneCanvas.width, sceneCanvas.height);
  // BOARD
  boardCtx.clearRect(0,0, boardCanvas.width, boardCanvas.height);
  board.draw(boardCtx);
  particles.draw(boardCtx);
}
function loop(now){
  const dt = Math.min(0.033, (now - lastT)/1000); lastT = now; timeNow += dt;
  update(dt); render(); requestAnimationFrame(loop);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –í–≤–æ–¥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let pointerDown = false;
boardCanvas.addEventListener('pointerdown', (e)=>{
  if(gameState!==STATE.RUN) return;
  sound.init();
  pointerDown = true;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if(cell) board.pointerDown(cell);
});
boardCanvas.addEventListener('pointermove', (e)=>{
  if(!pointerDown || gameState!==STATE.RUN) return;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if(cell) board.pointerMove(cell);
});
window.addEventListener('pointerup', ()=>{ if(!pointerDown) return; pointerDown=false; board.pointerUp(); });

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ö–æ–Ω—Ç—Ä–æ–ª—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('btnRestart').addEventListener('click', ()=> initGame(document.getElementById('mode').value));
document.getElementById('btnPause').addEventListener('click', ()=>{
  if(gameState===STATE.RUN){ gameState=STATE.PAUSE; overlayTitle.textContent="–ü–∞—É–∑–∞"; overlaySub.textContent="–ò–≥—Ä–∞ –Ω–∞ –ø–∞—É–∑–µ."; overlay.classList.add('show'); }
  else if(gameState===STATE.PAUSE){ gameState=STATE.RUN; overlay.classList.remove('show'); }
});
btnAgain.addEventListener('click', ()=>{ initGame(document.getElementById('mode').value); });
btnContinue.addEventListener('click', ()=>{ if(gameState===STATE.PAUSE){ gameState=STATE.RUN; } overlay.classList.remove('show'); });
document.getElementById('mode').addEventListener('change', e=> initGame(e.target.value));

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –°—Ç–∞—Ä—Ç ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
resize(); initGame("lava"); requestAnimationFrame(loop);
</script>
</body>
</html>
