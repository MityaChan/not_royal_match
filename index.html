<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Ğ¡Ğ¿Ğ°ÑĞ¸ ĞœĞ¾Ğ½Ğ°Ñ€Ñ…Ğ° â€” v2 (Ğ¿Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸, Ğ·Ğ²ÑƒĞº)</title>
  <style>
    :root{
      --bg:#0f1222;
      --bg-panel:#171a33;
      --ink:#e6e8ff;
      --muted:#a9afd6;
      --accent:#7c9bff;
      --accent-2:#f6b76b;
      --danger:#ff5a7a;
      --success:#4ee1a0;
      --gold:#ffd166;
      --shadow:rgba(0,0,0,.35);
      --glass:rgba(255,255,255,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 80% -10%, #233 0%, rgba(0,0,0,0) 70%), radial-gradient(1400px 900px at 0% 0%, #19203b 0%, rgba(0,0,0,0) 70%), linear-gradient(180deg, #0b0e1a 0%, #10132a 100%);
      color:var(--ink);
      font: 15px/1.35 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      overflow:hidden;
      touch-action:none;
    }
    .wrap{
      height:100dvh;
      display:grid;
      grid-template-rows: 56px 1fr;
      gap:10px; padding:10px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px; padding:8px 10px;
      box-shadow: 0 12px 30px var(--shadow);
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .title{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px; text-shadow: 0 2px 8px rgba(0,0,0,.3); }
    .crown{
      width:28px; height:28px; display:inline-grid; place-items:center;
      background: radial-gradient(circle at 50% 30%, #fff7, #fff0), linear-gradient(180deg, #ffdf7e, #f0b030);
      box-shadow: inset 0 -2px 4px rgba(0,0,0,.2), 0 4px 10px rgba(0,0,0,.4);
      border-radius:6px;
      clip-path: polygon(8% 65%, 25% 35%, 35% 65%, 50% 28%, 64% 65%, 75% 35%, 92% 65%, 92% 86%, 8% 86%);
    }
    .controls{ display:flex; gap:8px; align-items:center; }
    .btn, .icon-btn{
      appearance:none; border:0; cursor:pointer; color:var(--ink);
      padding:8px 12px; border-radius:10px;
      background: linear-gradient(180deg, #2a2f59, #1b1f3b);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 2px 0 rgba(255,255,255,.08);
      font-weight:700;
    }
    .icon-btn{ width:40px; padding:8px; display:grid; place-items:center; }
    .btn:active,.icon-btn:active{ transform: translateY(1px) scale(.995); }
    .btn.secondary{ background: linear-gradient(180deg, #2a2b35, #1b1c29); }
    select{
      appearance:none; background: linear-gradient(180deg, #2a2f59, #1b1f3b);
      color:var(--ink); border-radius:10px; padding:8px 12px; border:1px solid rgba(255,255,255,.08);
      font-weight:700; box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 2px 0 rgba(255,255,255,.08);
    }
    .main{ display:grid; grid-template-rows: 1fr auto; gap:10px; min-height:0; }
    .panel{ position:relative; border-radius:18px; overflow:hidden; border:1px solid rgba(255,255,255,.08);
      background: radial-gradient(1600px 800px at 80% -10%, rgba(255,255,255,.06), rgba(255,255,255,.02)), linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.04));
      box-shadow: 0 20px 40px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.08); backdrop-filter: blur(10px); min-height:0;
    }
    .scene{ display:grid; grid-template-rows: 1fr; min-height:0; }
    .board{ display:grid; grid-template-rows: 1fr; min-height:300px; }
    canvas{ width:100%; height:100%; display:block; }
    .hud{ position:absolute; left:10px; right:10px; top:10px; display:flex; gap:8px; align-items:center; z-index:5; pointer-events:none; }
    .meter{ flex:1; height:14px; border-radius:999px; overflow:hidden; background: rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.12); box-shadow: inset 0 1px 2px rgba(0,0,0,.5); }
    .meter > .fill{ height:100%; width:40%; background: linear-gradient(90deg, #ff6f91, #ffa26f); box-shadow: 0 4px 12px rgba(255,100,120,.45); transition: width .25s ease-out; }
    .hud .pill{ pointer-events:auto; padding:6px 10px; border-radius:999px; background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(6px); font-weight:800; font-feature-settings: "tnum" 1; letter-spacing:.3px; display:flex; gap:6px; align-items:center; }
    .hud .pill .dot{ width:10px; height:10px; border-radius:999px; background: var(--success); box-shadow:0 0 12px var(--success); }
    .hud .pill.red .dot{ background: var(--danger); box-shadow:0 0 12px var(--danger); }
    .overlay{ position:absolute; inset:0; display:none; place-items:center; background: rgba(0,0,0,.55); z-index:10; }
    .overlay.show{ display:grid; }
    .dialog{ width:min(92%, 520px); border-radius:18px; padding:24px; background: linear-gradient(180deg, #1b1f3e, #12152a); border:1px solid rgba(255,255,255,.12); box-shadow: 0 30px 60px rgba(0,0,0,.6), inset 0 1px 0 rgba(255,255,255,.08); text-align:center; }
    .big{ font-size:26px; font-weight:900; margin:0 0 8px; letter-spacing:.4px; text-shadow: 0 4px 18px rgba(0,0,0,.5); }
    .sub{ color: var(--muted); margin-bottom:16px; }
    .dialog .actions{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
    .pill-btn{ cursor:pointer; padding:10px 16px; border-radius:999px; font-weight:800; border:0; background: linear-gradient(180deg, #2b2f59, #1c1f3b); color:var(--ink); border:1px solid rgba(255,255,255,.08); box-shadow: 0 10px 18px rgba(0,0,0,.45), inset 0 2px 0 rgba(255,255,255,.06); }
    .pill-btn:active{ transform: translateY(1px); }
    .pill-btn.gold{ background: linear-gradient(180deg, #ffd166, #d8a52e); color:#2c2100; }
    .legend{ position:absolute; right:10px; bottom:10px; left:10px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:center; z-index:3; pointer-events:none; }
    .tag{ pointer-events:auto; background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(6px); padding:6px 10px; border-radius:999px; font-weight:700; color:var(--muted); display:flex; gap:6px; align-items:center; }
    .tag .swatch{ width:12px; height:12px; border-radius:3px; }
    .tag strong{ color:var(--ink); }
    @media (min-aspect-ratio: 10/16){ .main{ grid-template-rows: 1fr min(52vh, 680px); } }
    @media (max-aspect-ratio: 10/16){ .main{ grid-template-rows: 1fr min(60vh, 760px); } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <div class="crown"></div>
        <div>Ğ¡ĞŸĞĞ¡Ğ˜ ĞœĞĞĞĞ Ğ¥Ğ</div>
      </div>
      <div class="controls">
        <select id="mode">
          <option value="lava">ğŸŒ‹ Ğ ĞµĞ¶Ğ¸Ğ¼: Ğ›Ğ°Ğ²Ğ°</option>
          <option value="dragon">ğŸ‰ Ğ ĞµĞ¶Ğ¸Ğ¼: Ğ”Ñ€Ğ°ĞºĞ¾Ğ½</option>
          <option value="ceiling">ğŸ§± Ğ ĞµĞ¶Ğ¸Ğ¼: ĞŸĞ¾Ñ‚Ğ¾Ğ»Ğ¾Ğº</option>
        </select>
        <button class="btn" id="btnRestart">ĞŸĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑĞº</button>
        <button class="btn secondary" id="btnPause">ĞŸĞ°ÑƒĞ·Ğ°</button>
        <button class="icon-btn" id="btnSound" title="Ğ—Ğ²ÑƒĞº">ğŸ”Š</button>
      </div>
    </header>

    <div class="main">
      <div class="panel scene">
        <div class="hud">
          <div class="pill" id="comboPill"><span class="dot"></span> ĞšĞ¾Ğ¼Ğ±Ğ¾: <span id="comboVal">x1</span></div>
          <div class="meter"><div class="fill" id="dangerFill"></div></div>
          <div class="pill red">ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ</div>
        </div>
        <canvas id="scene"></canvas>
        <div class="legend">
          <div class="tag"><div class="swatch" style="background:#ff6f91"></div> <span>Ğ¡Ğ±Ñ€Ğ¾Ñ Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ Ğ·Ğ° Ñ‚Ğ°Ğ¹Ğ»</span> <strong>âˆ’1</strong></div>
          <div class="tag"><div class="swatch" style="background:#4ee1a0"></div> <span>Ğ‘Ğ¾Ğ½ÑƒÑ ĞºĞ°ÑĞºĞ°Ğ´Ğ°</span> <strong>+20%</strong></div>
          <div class="tag"><div class="swatch" style="background:#7c9bff"></div> <span>ĞšĞ¾Ğ¼Ğ±Ğ¾â€‘Ğ¼Ğ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ</span> <strong>Ğ´Ğ¾ Ã—5</strong></div>
        </div>
      </div>

      <div class="panel board">
        <canvas id="board"></canvas>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="dialog">
        <div class="big" id="overlayTitle">ĞŸĞ¾Ğ±ĞµĞ´Ğ°!</div>
        <div class="sub" id="overlaySub">ĞœĞ¾Ğ½Ğ°Ñ€Ñ… ÑĞ¿Ğ°ÑÑ‘Ğ½. Ğ¡Ñ‹Ğ³Ñ€Ğ°ĞµĞ¼ ĞµÑ‰Ñ‘?</div>
        <div class="actions">
          <button class="pill-btn gold" id="btnAgain">Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ ÑĞ½Ğ¾Ğ²Ğ°</button>
          <button class="pill-btn" id="btnContinue">ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ</button>
        </div>
      </div>
    </div>
  </div>

<script>
/*  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Ğ¡ĞŸĞĞ¡Ğ˜ ĞœĞĞĞĞ Ğ¥Ğ â€” v2: Ğ¿Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸, ÑƒĞ»ÑƒÑ‡ÑˆÑ‘Ğ½Ğ½Ğ°Ñ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°, Ğ¼ĞµĞ½ÑŒÑˆĞµ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ², Ğ·Ğ²ÑƒĞºĞ¸.
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a, b, t) => a + (b - a) * t;
const rnd = (a=1, b=0) => Math.random() * (a - b) + b;
const easeIn = t => t*t;
const easeOut = t => 1 - Math.pow(1 - t, 3);
const easeInOut = t => t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
let idCounter=1; const uid=()=>idCounter++;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CONFIG = {
  rows: 8,
  cols: 8,
  tileTypes: 5,             // Ğ¼ĞµĞ½ÑŒÑˆĞµ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ² â†’ Ğ»ĞµĞ³Ñ‡Ğµ Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ¼Ğ°Ñ‚Ñ‡
  gravity: 1600,
  swapTime: 0.25,           // ĞŸĞ›ĞĞ’ĞĞ•Ğ•: Ğ²Ñ€ĞµĞ¼Ñ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°
  clearTime: 0.34,          // ĞŸĞ›ĞĞ’ĞĞ•Ğ•: Ğ²Ñ€ĞµĞ¼Ñ Ğ¸ÑÑ‡ĞµĞ·Ğ½Ğ¾Ğ²ĞµĞ½Ğ¸Ñ
  fallLambda: 16,           // ĞŸĞ›ĞĞ’ĞĞ•Ğ•: Â«ÑƒĞ¿Ñ€ÑƒĞ³Ğ¾ÑÑ‚ÑŒÂ» Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ (Ğ±Ğ¾Ğ»ÑŒÑˆĞµ â€” Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ)
  spawnRise: 9,             // Ğ½Ğ° ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ĞºĞ»ĞµÑ‚Ğ¾Ğº Ğ²Ñ‹ÑˆĞµ ÑĞ¿Ğ°Ğ²Ğ½Ğ¸Ğ¼
  spawnDelayPerRow: .02,
  baseHazardRise: .040,
  hazardPerTile: .012,
  cascadeBonus: .20,
  maxComboMultiplier: 5,
  shuffleIfNoMoves: true,
  portraitBoardScale: .94,
  sfx: true
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞšĞ°Ğ½Ğ²Ğ°ÑÑ‹ Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sceneCanvas = document.getElementById('scene');
const boardCanvas = document.getElementById('board');
const sceneCtx = sceneCanvas.getContext('2d');
const boardCtx = boardCanvas.getContext('2d', { alpha: true });

let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
let boardRectPx = { x:0, y:0, w:0, h:0, cell: 0 };
let timeNow = 0;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const scenePanel = sceneCanvas.parentElement.getBoundingClientRect();
  const boardPanel = boardCanvas.parentElement.getBoundingClientRect();

  // SCENE
  sceneCanvas.width = Math.floor(scenePanel.width * DPR);
  sceneCanvas.height = Math.floor(scenePanel.height * DPR);
  sceneCanvas.style.width = scenePanel.width + "px";
  sceneCanvas.style.height = scenePanel.height + "px";

  // BOARD
  boardCanvas.width = Math.floor(boardPanel.width * DPR);
  boardCanvas.height = Math.floor(boardPanel.height * DPR);
  boardCanvas.style.width = boardPanel.width + "px";
  boardCanvas.style.height = boardPanel.height + "px";

  // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€ÑĞ¼Ğ¾ÑƒĞ³Ğ¾Ğ»ÑŒĞ½Ğ¸Ğº Ğ¿Ğ¾Ğ»Ñ
  const cols = CONFIG.cols, rows = CONFIG.rows;
  const padding = 16 * DPR;
  const usableW = boardCanvas.width - padding*2;
  const usableH = boardCanvas.height - padding*2;
  const cell = Math.floor(Math.min(usableW/cols, usableH/rows));
  const boardW = cell * cols;
  const boardH = cell * rows;
  boardRectPx = {
    x: Math.floor((boardCanvas.width - boardW)/2),
    y: Math.floor((boardCanvas.height - boardH)/2),
    w: boardW, h: boardH, cell
  };
}
window.addEventListener('resize', resize);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ—Ğ²ÑƒĞº (WebAudio) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Sound{
  constructor(){
    this.ctx = null;
    this.enabled = CONFIG.sfx;
    this.noiseBuf = null;
  }
  init(){
    if(this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    // Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ ÑˆÑƒĞ¼Ğ¾Ğ²Ğ¾Ğ¹ Ğ±ÑƒÑ„ĞµÑ€ Ğ´Ğ»Ñ Ğ²Ğ·Ñ€Ñ‹Ğ²Ğ¾Ğ²/Ğ¿ÑƒĞ·Ñ‹Ñ€ĞµĞ¹
    const len = this.ctx.sampleRate * 0.2;
    const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<len;i++) data[i] = (Math.random()*2-1) * (1 - i/len);
    this.noiseBuf = buf;
  }
  _gain(value=0.2, t=this.ctx.currentTime){
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(value, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.15);
    return g;
  }
  pop(pitch=440, vol=0.25){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    o.type = "triangle";
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.2);
    o.frequency.setValueAtTime(pitch, t0);
    o.frequency.linearRampToValueAtTime(pitch*0.6, t0+0.2);
    o.connect(g).connect(this.ctx.destination);
    o.start(t0); o.stop(t0+0.22);
  }
  blipUp(){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    o.type = "sine";
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.15, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.18);
    o.frequency.setValueAtTime(220, t0);
    o.frequency.exponentialRampToValueAtTime(500, t0+0.18);
    o.connect(g).connect(this.ctx.destination);
    o.start(t0); o.stop(t0+0.2);
  }
  blipDown(){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    o.type = "sine";
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.12, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.22);
    o.frequency.setValueAtTime(500, t0);
    o.frequency.exponentialRampToValueAtTime(180, t0+0.22);
    o.connect(g).connect(this.ctx.destination);
    o.start(t0); o.stop(t0+0.24);
  }
  burstSparkles(count=1){
    if(!this.enabled || !this.ctx) return;
    for(let i=0;i<count;i++){
      const pitch = 650 + i*70 + Math.random()*30;
      this.pop(pitch, 0.18);
    }
  }
  noiseWhoosh(len=0.25, vol=0.2){
    if(!this.enabled || !this.ctx) return;
    const t0 = this.ctx.currentTime;
    const src = this.ctx.createBufferSource();
    src.buffer = this.noiseBuf;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+len);
    const bp = this.ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 800;
    bp.Q.value = 0.6;
    src.connect(bp).connect(g).connect(this.ctx.destination);
    src.start(t0); src.stop(t0+len);
  }
  win(){
    if(!this.enabled || !this.ctx) return;
    this.burstSparkles(4);
    setTimeout(()=>this.pop(880,0.22), 120);
  }
  lose(){
    if(!this.enabled || !this.ctx) return;
    this.blipDown();
  }
}
const sound = new Sound();
const btnSound = document.getElementById('btnSound');
btnSound.addEventListener('click', ()=>{
  sound.enabled = !sound.enabled;
  btnSound.textContent = sound.enabled ? "ğŸ”Š" : "ğŸ”ˆ";
});
// Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµĞ¼ Ğ°ÑƒĞ´Ğ¸Ğ¾ Ğ¿Ğ¾ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¼Ñƒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
const unlockAudio = ()=>{ try{ sound.init(); document.removeEventListener('pointerdown', unlockAudio); }catch(e){} };
document.addEventListener('pointerdown', unlockAudio, { once:true });

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸Ğ³Ñ€Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STATE = { RUN:'run', PAUSE:'pause', WIN:'win', LOSE:'lose' };
let gameState = STATE.RUN;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ§Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ParticleSystem{
  constructor(){ this.ps = []; }
  burst(x,y,color, count=18){
    for(let i=0;i<count;i++){
      this.ps.push({
        x, y,
        vx: (rnd(-1,1))* (60 + 60*Math.random()),
        vy: (rnd(-1, -2)) * (60 + 60*Math.random()),
        life: .7 + Math.random()*.5,
        t: 0,
        size: 2 + Math.random()*3,
        color,
        rot: Math.random()*Math.PI,
        vr: rnd(-3,3),
      });
    }
  }
  update(dt){
    this.ps = this.ps.filter(p => (p.t += dt) < p.life);
    for(const p of this.ps){
      p.vy += 800 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.rot += p.vr * dt;
    }
  }
  draw(ctx){
    ctx.save();
    for(const p of this.ps){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }
}
const particles = new ParticleSystem();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ”Ğ¾ÑĞºĞ° (Ğ¼Ğ°Ñ‚Ñ‡â€‘3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Tile{
  constructor(type, r, c){
    this.id = uid();
    this.type = type;
    this.r = r; this.c = c;
    this.x = c; this.y = r; // Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² ĞºĞ»ĞµÑ‚ĞºĞ°Ñ… (Ğ´Ğ»Ñ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸)
    this.clearing = false;
    this.clearT = 0;
    this.spawnPulse = 0; // Ğ´Ğ»Ñ Ğ»Ñ‘Ğ³ĞºĞ¾Ğ³Ğ¾ Â«Ğ²Ğ´Ğ¾Ñ…â€‘Ğ²Ñ‹Ğ´Ğ¾Ñ…Ğ°Â»
  }
}

class Board{
  constructor(rows, cols, types){
    this.rows = rows;
    this.cols = cols;
    this.types = types;
    this.grid = [];
    this.animating = false;
    this.selected = null;
    this.swapping = null; // {a,b, ax0,ay0,bx0,by0,t}
    this.cascadeChain = 0;
    this.combo = 1;
    this.comboDecay = 0;
    this.afterFall = null;
    this._initGrid();
  }
  _randType(){ return (Math.random()*this.types|0); }
  _wouldMatchWithType(r,c,t){
    const eq=(rr,cc)=> (rr>=0&&cc>=0&&rr<this.rows&&cc<this.cols && this.grid[rr][cc] && this.grid[rr][cc].type===t);
    // Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹
    if(eq(r,c-1)&&eq(r,c-2)) return true;
    if(eq(r,c-1)&&eq(r,c+1)) return true;
    if(eq(r,c+1)&&eq(r,c+2)) return true;
    // Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ
    if(eq(r-1,c)&&eq(r-2,c)) return true;
    if(eq(r-1,c)&&eq(r+1,c)) return true;
    if(eq(r+1,c)&&eq(r+2,c)) return true;
    return false;
  }
  _randTypeAvoidSpawn(r,c){
    let tries = 0;
    while(true){
      const t = this._randType();
      if(!this._wouldMatchWithType(r,c,t)) return t;
      if(++tries>20) return t; // ÑÑ‚Ñ€Ğ°Ñ…Ğ¾Ğ²ĞºĞ°
    }
  }
  _randTypeAvoid(r,c){
    // Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ: Ğ¸Ğ·Ğ±ĞµĞ³Ğ°ĞµĞ¼ 3 Ğ¿Ğ¾Ğ´Ñ€ÑĞ´ Ğ¿Ğ¾ Ğ»ĞµĞ²Ğ¾Ğ¼Ñƒ/Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¼Ñƒ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ
    let t, tries=0;
    do{
      t = this._randType();
      tries++;
    } while(
      (c>=2 && this.grid[r]?.[c-1]?.type===t && this.grid[r]?.[c-2]?.type===t) ||
      (r>=2 && this.grid[r-1]?.[c]?.type===t && this.grid[r-2]?.[c]?.type===t)
    && tries<30);
    return t;
  }
  _initGrid(){
    this.grid = Array.from({length:this.rows}, (_,r)=>
      Array.from({length:this.cols}, (_,c)=> new Tile(this._randTypeAvoid(r,c), r, c))
    );
    if(!this.hasAnyMoves()){
      this.shuffle();
    }
  }
  tileAt(r,c){ if(r<0||c<0||r>=this.rows||c>=this.cols) return null; return this.grid[r][c]; }
  *allTiles(){ for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) yield this.grid[r][c]; }

  update(dt){
    // Ğ¿Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğº Ñ†ĞµĞ»ĞµĞ²Ñ‹Ğ¼ ĞºĞ»ĞµÑ‚ĞºĞ°Ğ¼ (Ğ¸ Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ, Ğ¸ swap)
    if(this.swapping){
      const s = this.swapping;
      s.t = Math.min(1, s.t + dt/CONFIG.swapTime);
      const k = easeInOut(s.t);
      // Ğ¸Ğ½Ñ‚ĞµÑ€Ğ¿Ğ¾Ğ»Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ñ€ÑĞ¼Ğ¾ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹ x/y Ğº Ñ†ĞµĞ»ÑĞ¼
      s.a.x = lerp(s.ax0, s.ax1, k);
      s.a.y = lerp(s.ay0, s.ay1, k);
      s.b.x = lerp(s.bx0, s.bx1, k);
      s.b.y = lerp(s.by0, s.by1, k);
      if(s.t>=1){ this.swapping=null; }
    }
    let allSnapped = true;
    for(const t of this.allTiles()){
      // Ğ¿Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ/Ğ¿Ğ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ
      t.x = damp(t.x, t.c, CONFIG.fallLambda, dt);
      t.y = damp(t.y, t.r, CONFIG.fallLambda, dt);
      if(Math.abs(t.x - t.c) > 0.01 || Math.abs(t.y - t.r) > 0.01) allSnapped = false;

      // Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¸ÑÑ‡ĞµĞ·Ğ½Ğ¾Ğ²ĞµĞ½Ğ¸Ñ
      if(t.clearing){
        t.clearT += dt;
      }
      // Ğ¿ÑƒĞ»ÑŒÑ Ğ¿Ñ€Ğ¸ ÑĞ¿Ğ°Ğ²Ğ½Ğµ
      if(t.spawnPulse>0){ t.spawnPulse = Math.max(0, t.spawnPulse - dt); }
    }
    if(this.animating && allSnapped && !this.swapping){
      this.animating = false;
      const cb = this.afterFall; this.afterFall = null;
      cb && cb();
    }
  }

  draw(ctx){
    const {x:bx, y:by, cell} = boardRectPx;
    ctx.save(); ctx.translate(bx, by);
    drawBoardBack(ctx, this.rows, this.cols, cell);
    const tiles = [...this.allTiles()].sort((a,b)=> (a.y - b.y) || (a.x - b.x));
    for(const t of tiles){ drawGem(ctx, t, cell); }
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = Math.max(1, cell*0.03);
    ctx.strokeRect(0,0, this.cols*cell, this.rows*cell);
    if(this.selected){
      const {r,c} = this.selected;
      ctx.save(); ctx.globalAlpha=.22; ctx.fillStyle = "#fff"; ctx.fillRect(c*cell, r*cell, cell, cell); ctx.restore();
    }
    ctx.restore();
  }

  screenToCell(px, py){
    const {x:bx,y:by,cell,w,h} = boardRectPx;
    const c = Math.floor((px*DPR - bx) / cell);
    const r = Math.floor((py*DPR - by) / cell);
    if(r<0||c<0||r>=this.rows||c>=this.cols) return null;
    return {r,c};
  }

  pointerDown(cell){ if(this.animating || this.swapping) return; this.selected = cell; }
  pointerMove(cell){
    if(this.animating || !this.selected || !cell) return;
    const dr = cell.r - this.selected.r;
    const dc = cell.c - this.selected.c;
    if(Math.abs(dr)+Math.abs(dc) === 1){
      this.trySwap(this.selected, cell);
      this.selected = null;
    }
  }
  pointerUp(){ if(this.animating) return; this.selected = null; }

  trySwap(a,b){
    if(!a||!b) return;
    const ta = this.tileAt(a.r,a.c);
    const tb = this.tileAt(b.r,b.c);
    if(!ta||!tb) return;

    // Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ğ¼ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ
    this.animating = true;
    const s = {
      a:ta, b:tb, t:0,
      ax0: ta.x, ay0: ta.y,
      bx0: tb.x, by0: tb.y,
      ax1: tb.c, ay1: tb.r,
      bx1: ta.c, by1: ta.r,
      revert:false
    };
    this.swapping = s;

    // Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¼ĞµÑÑ‚Ğ°Ğ¼Ğ¸
    [this.grid[ta.r][ta.c], this.grid[tb.r][tb.c]] = [tb, ta];
    [ta.r, tb.r] = [tb.r, ta.r];
    [ta.c, tb.c] = [tb.c, ta.c];

    // Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹
    const matches = this.findMatches();
    if(matches.length === 0){
      // Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚: Ğ¿Ñ€Ğ¾Ğ¸Ğ³Ñ€Ñ‹Ğ²Ğ°ĞµĞ¼ Â«Ğ±Ğ¸Ğ¿ Ğ²Ğ½Ğ¸Ğ·Â»
      sound.blipDown();
      // Ğ¾Ñ‚ĞºĞ°Ñ‚ Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ñ‹ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸
      setTimeout(()=>{
        // Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸
        [this.grid[ta.r][ta.c], this.grid[tb.r][tb.c]] = [tb, ta];
        [ta.r, tb.r] = [tb.r, ta.r];
        [ta.c, tb.c] = [tb.c, ta.c];
        // Ğ¸ Ğ°Ğ½Ğ¸Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾
        this.swapping = {
          a:ta, b:tb, t:0,
          ax0: ta.x, ay0: ta.y,
          bx0: tb.x, by0: tb.y,
          ax1: tb.c, ay1: tb.r,
          bx1: ta.c, by1: ta.r,
        };
        // Ğ¿Ğ¾ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ğ¸ â€” ÑĞ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ
        setTimeout(()=>{ this.animating=false; this.swapping=null; }, CONFIG.swapTime*1000+20);
      }, CONFIG.swapTime*1000*0.6);
      return;
    }

    // ÑƒĞ´Ğ°Ñ‡Ğ½Ñ‹Ğ¹ ÑĞ²Ğ¾Ğ¿ â€” Ğ¿Ñ€Ğ¸ÑÑ‚Ğ½Ñ‹Ğ¹ Ğ±Ğ¸Ğ¿ Ğ²Ğ²ĞµÑ€Ñ…
    sound.blipUp();
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ĞºĞ°ÑĞºĞ°Ğ´
    this.cascadeChain = 0;
    this.resolveCascade(matches);
  }

  findMatches(){
    const matches = [];
    // Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ
    for(let r=0;r<this.rows;r++){
      let runType = null, runStart = 0, runLen = 0;
      for(let c=0;c<this.cols;c++){
        const t = this.grid[r][c];
        if(t.type === runType) runLen++;
        else{
          if(runLen>=3) matches.push({dir:'h', tiles: Array.from({length:runLen},(_,i)=>this.grid[r][runStart+i])});
          runType = t.type; runStart = c; runLen = 1;
        }
      }
      if(runLen>=3) matches.push({dir:'h', tiles: Array.from({length:runLen},(_,i)=>this.grid[r][runStart+i])});
    }
    // Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ
    for(let c=0;c<this.cols;c++){
      let runType = null, runStart = 0, runLen = 0;
      for(let r=0;r<this.rows;r++){
        const t = this.grid[r][c];
        if(t.type === runType) runLen++;
        else{
          if(runLen>=3) matches.push({dir:'v', tiles: Array.from({length:runLen},(_,i)=>this.grid[runStart+i][c])});
          runType = t.type; runStart = r; runLen = 1;
        }
      }
      if(runLen>=3) matches.push({dir:'v', tiles: Array.from({length:runLen},(_,i)=>this.grid[runStart+i][c])});
    }
    // ÑƒĞ½Ğ¸ĞºĞ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ°Ğ¹Ğ»Ñ‹
    const uniq = new Set(), result = [];
    for(const m of matches){
      const group = [];
      for(const t of m.tiles){ if(!uniq.has(t.id)){ uniq.add(t.id); group.push(t); } }
      if(group.length>=3) result.push({dir:m.dir, tiles:group});
    }
    return result;
  }

  hasAnyMoves(){
    for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){
      const t = this.grid[r][c];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){
        const r2=r+dr, c2=c+dc;
        if(r2<0||c2<0||r2>=this.rows||c2>=this.cols) continue;
        const u = this.grid[r2][c2];
        [t.type, u.type] = [u.type, t.type];
        const has = this._hasMatchAt(r,c) || this._hasMatchAt(r2,c2);
        [t.type, u.type] = [u.type, t.type];
        if(has) return true;
      }
    }
    return false;
  }
  _hasMatchAt(r,c){
    const t = this.grid[r][c]; const type = t.type;
    let cnt=1, cc=c-1; while(cc>=0 && this.grid[r][cc].type===type) {cnt++;cc--;}
    cc=c+1; while(cc<this.cols && this.grid[r][cc].type===type) {cnt++;cc++;}
    if(cnt>=3) return true;
    cnt=1; let rr=r-1; while(rr>=0 && this.grid[rr][c].type===type) {cnt++;rr--;}
    rr=r+1; while(rr<this.rows && this.grid[rr][c].type===type) {cnt++;rr++;}
    return cnt>=3;
  }

  shuffle(){
    let flat = [...this.allTiles()];
    for(let i=flat.length-1;i>0;i--){
      const j = (Math.random()*(i+1)|0);
      [flat[i].type, flat[j].type] = [flat[j].type, flat[i].type];
    }
    if(!this.hasAnyMoves()) this.shuffle();
  }

  resolveCascade(initialMatches){
    let wave = initialMatches;
    const loop = ()=>{
      if(!wave || wave.length===0){
        this.animating = false;
        this.swapping = null;
        this.cascadeChain = 0;
        this.comboDecay = 2.5;
        return;
      }
      this.cascadeChain++;
      this.handleClear(wave);
      // Ñ‡ÑƒÑ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ñ‘Ğ¼ Ğ½Ğ° Â«Ğ¿Ğ¾Ğ¿Â»
      setTimeout(()=>{
        this.applyGravityAndSpawn(()=>{
          const next = this.findMatches();
          if(next.length>0) { wave = next; loop(); }
          else { wave = null; loop(); }
        });
      }, 160);
    };
    loop();
  }

  handleClear(matches){
    const byColumn = new Set();
    let cleared = 0;
    for(const m of matches){
      for(const t of m.tiles){
        if(t.clearing) continue;
        t.clearing = true; t.clearT = 0;
        byColumn.add(t.c);
        cleared++;
        // Ñ‡Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹
        const {cell,x:bx,y:by} = boardRectPx;
        const cx = bx + (t.c+0.5)*cell;
        const cy = by + (t.r+0.5)*cell;
        particles.burst(cx, cy, gemColor(t.type, 0.9), 16);
      }
    }
    // Ğ·Ğ²ÑƒĞºĞ¸ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ: Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞ°ĞµÑ‚ÑÑ Ñ ĞºĞ°ÑĞºĞ°Ğ´Ğ¾Ğ¼
    sound.burstSparkles(Math.min(4, Math.max(1, Math.round(this.cascadeChain))));
    // ĞºĞ¾Ğ¼Ğ±Ğ¾
    this.combo = clamp(this.combo + .35, 1, CONFIG.maxComboMultiplier);
    document.getElementById('comboVal').textContent = "x"+this.combo.toFixed(1).replace(".0","");
    // ÑƒĞ¼ĞµĞ½ÑŒÑˆĞ°ĞµĞ¼ Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ
    const cascadeFactor = 1 + (this.cascadeChain-1)*CONFIG.cascadeBonus;
    const effectivePerTile = CONFIG.hazardPerTile * cascadeFactor * this.combo;
    hazard?.onTilesCleared(cleared, Array.from(byColumn), effectivePerTile);
  }

  applyGravityAndSpawn(done){
    const {rows, cols} = this;
    // ÑĞ¼ĞµÑ‰Ğ°ĞµĞ¼ Ğ²Ğ½Ğ¸Ğ·
    for(let c=0;c<cols;c++){
      let writeRow = rows-1;
      for(let r=rows-1; r>=0; r--){
        const t = this.grid[r][c];
        if(t.clearing) continue;
        if(writeRow !== r){
          this.grid[writeRow][c] = t;
          t.r = writeRow; // Ñ†ĞµĞ»ĞµĞ²Ğ°Ñ
          writeRow--;
        } else {
          writeRow--;
        }
      }
      // Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¼Ğ¸, Ğ±ĞµĞ· ÑĞ¿Ğ°Ğ²Ğ½Ğ° 3â€‘Ğ²â€‘Ñ€ÑĞ´
      for(let r=writeRow; r>=0; r--){
        const type = this._randTypeAvoidSpawn(r,c);
        const nt = new Tile(type, r, c);
        nt.y = r - CONFIG.spawnRise; // Ğ¿Ñ€Ğ¸Ğ»ĞµÑ‚ ÑĞ²ĞµÑ€Ñ…Ñƒ
        nt.spawnPulse = 0.35;
        this.grid[r][c] = nt;
      }
    }
    // Ğ²ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ
    this.animating = true;
    this.afterFall = done;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ ĞµĞ½Ğ´ĞµÑ€ ĞºĞ°Ğ¼Ğ½ĞµĞ¹ Ğ¸ Ğ¿Ğ¾Ğ»Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const gemHues = [8, 220, 120, 50, 280]; // 5 Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²
function gemColor(type, a=1){
  const hue = gemHues[type % gemHues.length];
  return `hsla(${hue} 80% 55% / ${a})`;
}

function drawGem(ctx, t, cell){
  const bob = 0.02*Math.sin((timeNow*1.2 + (t.r*7 + t.c*11))*0.8);
  const px = (t.x + 0.5) * cell;
  const py = (t.y + 0.5 + bob) * cell;
  let scale = 0.92 + 0.04*Math.sin((timeNow + t.id)*0.5); // Ğ»Ñ‘Ğ³ĞºĞ¾Ğµ Ğ´Ñ‹Ñ…Ğ°Ğ½Ğ¸Ğµ
  if(t.spawnPulse>0){ scale += 0.12 * easeOut(1 - t.spawnPulse/0.35); }

  // Ğ¸ÑÑ‡ĞµĞ·Ğ½Ğ¾Ğ²ĞµĞ½Ğ¸Ğµ Ñ ĞºÑ€Ğ°ÑĞ¸Ğ²Ñ‹Ğ¼ Â«Ğ¿ÑƒÑ…Â»
  let alpha = 1;
  if(t.clearing){
    const u = clamp(t.clearT / CONFIG.clearTime, 0, 1);
    if(u < 0.18) scale = lerp(scale, 1.15, u/0.18);
    else scale = lerp(1.15, 0.0, (u-0.18)/0.82);
    alpha = 1 - u;
  }

  const size = cell * scale;
  ctx.save();
  ctx.translate(px, py);
  ctx.globalAlpha = alpha;

  // Ñ‚ĞµĞ½ÑŒ
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath(); ctx.ellipse(0, size*0.45, size*0.40, size*0.12, 0, 0, Math.PI*2); ctx.fill();

  // Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ½Ğ¸Ğº (Ğ¾ĞºÑ‚Ğ°Ğ³Ğ¾Ğ½) Ñ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ĞµĞ¹ Ğ³Ñ€Ğ°Ğ½ÑŒÑ Ğ¸ Ğ¾Ğ±Ğ²Ğ¾Ğ´ĞºĞ¾Ğ¹
  const hue = gemHues[t.type % gemHues.length];
  const outer = size*0.48;
  const inner = size*0.30;
  // ĞºĞ¾Ñ€Ğ¿ÑƒÑ
  const grad = ctx.createRadialGradient(-outer*0.2, -outer*0.25, outer*0.1, 0,0, outer*0.85);
  grad.addColorStop(0, `hsla(${hue} 85% 68% / 1)`);
  grad.addColorStop(1, `hsla(${hue} 80% 38% / 1)`);
  ctx.fillStyle = grad;

  ctx.beginPath();
  for(let i=0;i<8;i++){
    const a = Math.PI/4 * i + Math.PI/8;
    const x = Math.cos(a)*outer, y = Math.sin(a)*outer;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.fill();

  // Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ñ„Ğ°ÑĞºĞ°
  ctx.fillStyle = `hsla(${hue} 90% 80% / .35)`;
  ctx.beginPath();
  for(let i=0;i<8;i++){
    const a = Math.PI/4 * i + Math.PI/8;
    const x = Math.cos(a)*inner, y = Math.sin(a)*inner;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.fill();

  // Ğ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ñ Ğ³Ñ€Ğ°Ğ½ÑŒ
  ctx.globalCompositeOperation = "lighter";
  const shine = ctx.createLinearGradient(-outer, -outer, outer, outer);
  shine.addColorStop(0, "rgba(255,255,255,.15)");
  shine.addColorStop(0.5, "rgba(255,255,255,0)");
  ctx.fillStyle = shine;
  ctx.beginPath();
  ctx.moveTo(-outer*0.8, -outer*0.2);
  ctx.lineTo(outer*0.2, -outer*0.8);
  ctx.lineTo(outer*0.6, -outer*0.4);
  ctx.lineTo(-outer*0.4, outer*0.6);
  ctx.closePath();
  ctx.fill();
  ctx.globalCompositeOperation = "source-over";

  // ĞºĞ¾Ğ½Ñ‚ÑƒÑ€
  ctx.strokeStyle = "rgba(0,0,0,.35)";
  ctx.lineWidth = Math.max(1, cell*0.03);
  ctx.stroke();

  // Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ°Ñ Ğ¸ÑĞºĞ¾Ñ€ĞºĞ°
  ctx.fillStyle = "rgba(255,255,255,.7)";
  ctx.beginPath();
  ctx.arc(-outer*0.25, -outer*0.25, outer*0.09, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function drawBoardBack(ctx, rows, cols, cell){
  const w = cols*cell, h = rows*cell;
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, "rgba(255,255,255,.05)");
  grad.addColorStop(1, "rgba(255,255,255,.02)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);
  ctx.save();
  ctx.globalAlpha=.22;
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.lineWidth = Math.max(1, cell*0.02);
  for(let r=1;r<rows;r++){ const y=r*cell; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  for(let c=1;c<cols;c++){ const x=c*cell; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸/ÑÑ†ĞµĞ½Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class HazardBase{
  constructor(){ this.level = .55; this.lossRate = CONFIG.baseHazardRise; this.state='run'; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.level += this.lossRate * dt;
    if(this.level>=1){ this.level=1; onLose(); }
  }
  reduce(amount){ this.level = clamp(this.level - amount, 0, 1); if(this.level<=0) onWin(); }
  onTilesCleared(count, columns, perTileEffective){ this.reduce(count * perTileEffective); }
  draw(ctx, w, h){}
  name(){ return "ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ"; }
}
class LavaHazard extends HazardBase{
  constructor(){ super(); this.bubbles=[]; this.drains=[]; this.waveT=0; }
  name(){ return "Ğ›Ğ°Ğ²Ğ°"; }
  onTilesCleared(count, columns, perTileEffective){
    this.reduce(count * perTileEffective * 1.0);
    const now = performance.now();
    for(const c of columns){ this.drains.push({ t: now, col: c, life: 1000 }); }
    sound.noiseWhoosh(0.2, 0.12);
  }
  update(dt){
    super.update(dt);
    this.waveT += dt;
    const now = performance.now();
    this.drains = this.drains.filter(d => now - d.t < d.life);
    if(Math.random()<.06){
      this.bubbles.push({ x: rnd(0.05, 0.95), y: this.level - rnd(0.0, 0.1), r: rnd(2,5), t:0, life: rnd(.8,1.6) });
    }
    for(const b of this.bubbles){ b.t += dt; b.y -= dt*.05; b.x += Math.sin(b.t*2)*.0008; }
    this.bubbles = this.bubbles.filter(b => b.t<b.life);
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const platformY = h*0.22;
    drawKing(ctx, w*0.5, platformY, h*0.13);
    const lvlPix = h * this.level;
    const lavaTop = h - lvlPix;
    for(const d of this.drains){
      const x = (boardRectPx.x + (d.col+0.5)*boardRectPx.cell) / boardCanvas.width * w;
      drawDrainStream(ctx, x, lavaTop-6, 42, 0.9);
    }
    drawLava(ctx, 0, lavaTop, w, h-lavaTop, this.waveT);
    updateDangerUI(this.level);
  }
}
class DragonHazard extends HazardBase{
  constructor(){ super(); this.progress=.35; this.speed = .12; }
  name(){ return "Ğ”Ñ€Ğ°ĞºĞ¾Ğ½"; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.progress += this.speed*dt;
    this.level = clamp(this.progress, 0, 1);
    if(this.level>=1) onLose();
  }
  onTilesCleared(count, columns, perTileEffective){
    const push = count * perTileEffective * 0.9;
    this.progress = clamp(this.progress - push, 0, 1);
    this.level = this.progress;
    sound.noiseWhoosh(0.15, 0.1);
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const y = h*0.24;
    drawKing(ctx, w*0.18, y, h*0.13);
    const x = lerp(-w*0.2, w*0.48, this.progress);
    drawDragon(ctx, x, y+18, h*0.19);
    updateDangerUI(this.level);
  }
}
class CeilingHazard extends HazardBase{
  constructor(){ super(); this.ceiling = .25; this.speed=.08; }
  name(){ return "ĞŸĞ¾Ñ‚Ğ¾Ğ»Ğ¾Ğº"; }
  update(dt){
    if(gameState!==STATE.RUN) return;
    this.ceiling += this.speed*dt;
    this.level = clamp(this.ceiling, 0, .98);
    if(this.level>=.98) onLose();
  }
  onTilesCleared(count, columns, perTileEffective){
    const raise = count * perTileEffective * 1.1;
    this.ceiling = clamp(this.ceiling - raise, 0, .98);
    this.level = this.ceiling;
    sound.noiseWhoosh(0.15, 0.1);
  }
  draw(ctx, w, h){
    drawBackdrop(ctx, w, h);
    const ceilY = h * this.ceiling;
    ctx.fillStyle = "rgba(200,205,230,.18)";
    ctx.fillRect(0, 0, w, ceilY);
    ctx.strokeStyle = "rgba(255,255,255,.25)";
    ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0,ceilY); ctx.lineTo(w,ceilY); ctx.stroke();
    drawKing(ctx, w*0.5, ceilY + h*0.12, h*0.13);
    updateDangerUI(this.level);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ†ĞµĞ½Ñ‹ (Ñ€ĞµĞ°Ğ»Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½ĞµĞµ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBackdrop(ctx, w, h){
  // ĞĞµĞ±Ğ¾ ÑĞ¾ Ğ·Ğ²Ñ‘Ğ·Ğ´Ğ°Ğ¼Ğ¸ Ğ¸ Ğ»ÑƒĞ½Ğ¾Ğ¹
  const sky = ctx.createLinearGradient(0,0,0,h);
  sky.addColorStop(0, "#0b0f23");
  sky.addColorStop(1, "#151a37");
  ctx.fillStyle = sky; ctx.fillRect(0,0,w,h);

  // Ğ·Ğ²Ñ‘Ğ·Ğ´Ñ‹
  ctx.save();
  ctx.globalAlpha = 0.6;
  for(let i=0;i<120;i++){
    const x = (i*97 % w), y = (i*i*29 % h*0.6);
    const r = (i%7===0) ? 2 : 1;
    ctx.fillStyle = "rgba(255,255,255,.8)";
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // Ğ»ÑƒĞ½Ğ°
  ctx.save();
  const moonX = w*0.86, moonY = h*0.15, mr = Math.min(w,h)*0.04;
  const mg = ctx.createRadialGradient(moonX, moonY, mr*0.2, moonX, moonY, mr);
  mg.addColorStop(0, "rgba(255,255,240,1)");
  mg.addColorStop(1, "rgba(255,255,240,0)");
  ctx.fillStyle = mg; ctx.beginPath(); ctx.arc(moonX, moonY, mr, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // Ğ´Ğ°Ğ»Ñ‘ĞºĞ¸Ğµ Ğ³Ğ¾Ñ€Ñ‹
  ctx.fillStyle = "rgba(200,220,255,.06)";
  const y0 = h*0.58;
  ctx.beginPath(); ctx.moveTo(0,y0);
  for(let x=0;x<=w;x+=w/16){ const y = y0 - Math.sin(x/w*Math.PI*2)*h*0.035 - h*0.02; ctx.lineTo(x,y); }
  ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath(); ctx.fill();

  // Ğ·Ğ°Ğ¼Ğ¾Ğº/Ğ±Ğ°ÑˆĞ½Ğ¸ Ñ Ğ»Ñ‘Ğ³ĞºĞ¾Ğ¹ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹
  const tower = (cx, top, sc)=>{
    ctx.save(); ctx.translate(cx, top); ctx.scale(sc, sc);
    // Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    const grad = ctx.createLinearGradient(0,0,0,120);
    grad.addColorStop(0, "rgba(210,220,255,.16)");
    grad.addColorStop(1, "rgba(180,190,230,.08)");
    ctx.fillStyle = grad; roundRect(ctx, -18, 0, 36, 120, 4); ctx.fill();
    // Ğ·ÑƒĞ±Ñ†Ñ‹
    ctx.fillStyle = "rgba(220,230,255,.16)";
    roundRect(ctx, -26, -14, 52, 14, 4); ctx.fill();
    for(let i=-18;i<=18;i+=12){ roundRect(ctx, i-3, -24, 6, 10, 2); ctx.fill(); }
    // Ñ‚ĞµĞºÑÑ‚ÑƒÑ€Ğ° ĞºĞ¸Ñ€Ğ¿Ğ¸Ñ‡ĞµĞ¹
    ctx.strokeStyle = "rgba(255,255,255,.06)"; ctx.lineWidth = 1;
    for(let y=10;y<110;y+=10){ ctx.beginPath(); ctx.moveTo(-18,y); ctx.lineTo(18,y); ctx.stroke(); }
    ctx.restore();
  };
  tower(w*0.18, h*0.18, 1.2);
  tower(w*0.82, h*0.22, 1.05);
}

function drawKing(ctx, x, y, size){
  ctx.save(); ctx.translate(x,y);

  // Ñ‚ĞµĞ½ÑŒ
  ctx.fillStyle = "rgba(0,0,0,.38)"; ctx.beginPath(); ctx.ellipse(0, size*.72, size*.66, size*.18, 0, 0, Math.PI*2); ctx.fill();

  // Ğ¿Ğ»Ğ°Ñ‰
  const robeGrad = ctx.createLinearGradient(0, -size*.1, 0, size*.6);
  robeGrad.addColorStop(0, "#40489d"); robeGrad.addColorStop(1, "#242a66");
  ctx.fillStyle = robeGrad; roundRect(ctx, -size*.38, -size*.05, size*.76, size*.95, size*.22); ctx.fill();

  // Ğ¼ĞµÑ…Ğ¾Ğ²Ğ°Ñ Ğ¾Ğ¿ÑƒÑˆĞºĞ°
  ctx.fillStyle = "#e6e7ef"; roundRect(ctx, -size*.38, -size*.2, size*.76, size*.22, size*.12); ctx.fill();
  ctx.fillStyle = "#d1d3df"; roundRect(ctx, -size*.35, -size*.18, size*.70, size*.18, size*.10); ctx.fill();

  // Ğ»Ğ¸Ñ†Ğ¾
  const faceGrad = ctx.createLinearGradient(0, -size*.6, 0, -size*.1);
  faceGrad.addColorStop(0, "#f9dbbd"); faceGrad.addColorStop(1, "#eec6a2");
  ctx.fillStyle = faceGrad; roundRect(ctx, -size*.23, -size*.55, size*.46, size*.42, size*.12); ctx.fill();

  // Ğ½Ğ¾Ñ, Ğ³Ğ»Ğ°Ğ·Ğ°, Ğ±Ñ€Ğ¾Ğ²Ğ¸
  ctx.fillStyle = "#1b2048";
  ctx.beginPath(); ctx.arc(-size*.08, -size*.40, size*.035, 0, Math.PI*2); ctx.arc(size*.08, -size*.40, size*.035, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = "#1b2048"; ctx.lineWidth = size*.02; ctx.lineCap="round";
  ctx.beginPath(); ctx.moveTo(-size*.12, -size*.46); ctx.lineTo(-size*.02, -size*.46); ctx.moveTo(size*.02, -size*.46); ctx.lineTo(size*.12, -size*.46); ctx.stroke();
  ctx.fillStyle = "#e4b995"; roundRect(ctx, -size*.03, -size*.40, size*.06, size*.12, size*.03); ctx.fill();

  // ÑƒÑÑ‹ Ğ¸ Ğ±Ğ¾Ñ€Ğ¾Ğ´Ğ°
  ctx.strokeStyle = "#c2986a"; ctx.lineWidth = size*.045; ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(-size*.14, -size*.30); ctx.lineTo(-size*.02, -size*.30);
  ctx.moveTo(size*.02, -size*.30); ctx.lineTo(size*.14, -size*.30); ctx.stroke();
  ctx.fillStyle = "#b78b63"; roundRect(ctx, -size*.16, -size*.25, size*.32, size*.10, size*.04); ctx.fill();

  // ĞºĞ¾Ñ€Ğ¾Ğ½Ğ° Ñ Ğ´Ñ€Ğ°Ğ³Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑĞ¼Ğ¸
  ctx.fillStyle = "#ffd166";
  ctx.beginPath();
  ctx.moveTo(-size*.22, -size*.60);
  ctx.lineTo(-size*.08, -size*.84);
  ctx.lineTo(0, -size*.62);
  ctx.lineTo(size*.08, -size*.84);
  ctx.lineTo(size*.22, -size*.60);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle="rgba(0,0,0,.25)"; ctx.lineWidth=1.2; ctx.stroke();
  ctx.fillStyle="#8bd5ff"; ctx.beginPath(); ctx.arc(-size*.1, -size*.65, size*.035, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle="#ff8bc1"; ctx.beginPath(); ctx.arc(size*.1, -size*.65, size*.035, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawLava(ctx, x, y, w, h, t){
  const lavaGrad = ctx.createLinearGradient(0, y, 0, y+h);
  lavaGrad.addColorStop(0, "rgba(255,160,100,.98)");
  lavaGrad.addColorStop(.6, "rgba(240,90,60,.98)");
  lavaGrad.addColorStop(1, "rgba(80,20,20,.98)");
  ctx.fillStyle = lavaGrad; ctx.fillRect(x, y, w, h);
  // Ğ¿Ğ¾Ğ²ĞµÑ€Ñ…Ğ½Ğ¾ÑÑ‚ÑŒ
  ctx.save(); ctx.globalAlpha = .9; ctx.fillStyle = "rgba(255,210,120,.9)";
  ctx.beginPath();
  const base = y+8; ctx.moveTo(0, base);
  for(let i=0;i<=w;i+=12){ const wave = Math.sin((i*0.012 + t*4))*6 + Math.sin((i*0.022 - t*3))*4; ctx.lineTo(i, base + wave); }
  ctx.lineTo(w, y-40); ctx.lineTo(0, y-40); ctx.closePath(); ctx.fill(); ctx.restore();
  // Ğ¿ÑƒĞ·Ñ‹Ñ€ÑŒĞºĞ¸
  ctx.save();
  for(const b of hazard.bubbles || []){
    const px = b.x*w, py = y + b.y*h;
    ctx.globalAlpha = 0.8*(1 - b.t/b.life);
    ctx.fillStyle = "rgba(255,230,200,.7)";
    ctx.beginPath(); ctx.arc(px, py, b.r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}
function drawDrainStream(ctx, x, y, len, alpha){
  ctx.save();
  const grad = ctx.createLinearGradient(0,y,0,y+len);
  grad.addColorStop(0, "rgba(255,220,140,"+alpha+")");
  grad.addColorStop(1, "rgba(255,120,60,0)");
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.moveTo(x-3,y); ctx.lineTo(x+3,y); ctx.lineTo(x, y+len); ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawDragon(ctx, x, y, size){
  ctx.save(); ctx.translate(x,y);
  // Ñ‚ĞµĞ½ÑŒ
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath(); ctx.ellipse(0, size*0.6, size*0.7, size*0.18, 0, 0, Math.PI*2); ctx.fill();

  // Ñ‚ĞµĞ»Ğ¾
  const bodyGrad = ctx.createLinearGradient(-size*.4, 0, size*.4, 0);
  bodyGrad.addColorStop(0, "#5ec184"); bodyGrad.addColorStop(1, "#3aa967");
  ctx.fillStyle = bodyGrad; roundRect(ctx, -size*.45, -size*.18, size*.9, size*.36, size*.18); ctx.fill();

  // Ğ¶Ğ¸Ğ²Ğ¾Ñ‚ (ÑĞ²ĞµÑ‚Ğ»ĞµĞµ)
  ctx.fillStyle = "#82d9a4";
  roundRect(ctx, -size*.25, -size*.10, size*.5, size*.22, size*.10); ctx.fill();

  // Ñ…Ğ²Ğ¾ÑÑ‚
  ctx.fillStyle = "#46b275";
  ctx.beginPath(); ctx.moveTo(-size*.45, 0); ctx.quadraticCurveTo(-size*.75, -size*.2, -size*.9, 0); ctx.quadraticCurveTo(-size*.7, size*.2, -size*.45, 0); ctx.closePath(); ctx.fill();

  // ĞºÑ€Ñ‹Ğ»ÑŒÑ
  ctx.fillStyle="#3aa967";
  ctx.beginPath(); ctx.moveTo(-size*.1, -size*.12); ctx.quadraticCurveTo(size*.1, -size*.55, size*.35, -size*.12); ctx.lineTo(size*.0, -size*.02); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-size*.2, size*.12); ctx.quadraticCurveTo(size*.0, -size*.38, size*.25, size*.12); ctx.lineTo(-size*.05, size*.18); ctx.closePath(); ctx.fill();

  // Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ°
  roundRect(ctx, size*.28, -size*.14, size*.34, size*.20, size*.08); ctx.fill();
  // Ğ¶Ğ¸Ğ²Ğ¾Ñ‚Ğ¸Ğº Ğ³Ğ¾Ğ»Ğ¾Ğ²Ñ‹
  ctx.fillStyle="#82d9a4"; roundRect(ctx, size*.28, -size*.05, size*.26, size*.10, size*.05); ctx.fill();

  // Ñ€Ğ¾Ğ³ Ğ¸ Ñ‡ĞµĞ»ÑÑÑ‚ÑŒ
  ctx.fillStyle="#72d39a";
  ctx.beginPath(); ctx.moveTo(size*.44, -size*.22); ctx.lineTo(size*.52, -size*.32); ctx.lineTo(size*.48, -size*.18); ctx.closePath(); ctx.fill();
  ctx.fillStyle="#5ec184";
  ctx.beginPath(); ctx.moveTo(size*.62, -size*.02); ctx.lineTo(size*.78, -size*.08); ctx.lineTo(size*.62, size*.06); ctx.closePath(); ctx.fill();

  // Ğ³Ğ»Ğ°Ğ·
  ctx.fillStyle="#1b2048"; ctx.beginPath(); ctx.arc(size*.52, -size*.02, size*.022, 0, Math.PI*2); ctx.fill();

  // Ğ¾Ğ³Ğ¾Ğ½ÑŒ
  const fg = ctx.createRadialGradient(size*.86, -size*.02, size*.02, size*.86, -size*.02, size*.22);
  fg.addColorStop(0, "rgba(255,240,200,1)");
  fg.addColorStop(1, "rgba(255,120,0,0.0)");
  ctx.fillStyle = fg;
  ctx.beginPath();
  ctx.moveTo(size*.58, -size*.02);
  ctx.quadraticCurveTo(size*.7, -size*.16, size*.86, -size*.02);
  ctx.quadraticCurveTo(size*.7, size*.16, size*.58, -size*.02);
  ctx.closePath(); ctx.fill();

  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI/ĞĞ²ĞµÑ€Ğ»ĞµĞ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySub = document.getElementById('overlaySub');
const btnAgain = document.getElementById('btnAgain');
const btnContinue = document.getElementById('btnContinue');
const dangerFill = document.getElementById('dangerFill');
const comboPill = document.getElementById('comboPill');

function showOverlay(title, sub){ overlayTitle.textContent = title; overlaySub.textContent = sub; overlay.classList.add('show'); }
function hideOverlay(){ overlay.classList.remove('show'); }

function updateDangerUI(level){
  dangerFill.style.width = (level*100).toFixed(1) + "%";
  const g = Math.max(0, 1 - level*1.2);
  const r = Math.min(1, level*1.2);
  dangerFill.style.background = `linear-gradient(90deg, rgba(${255*Math.min(1, r+.2)},${120*g},100,1), rgba(${255},${160*(1-g)},110,1))`;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ˜Ğ³Ñ€Ğ°: Ñ†Ğ¸ĞºĞ» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let board = null;
let hazard = null;
let lastT = performance.now();

function initGame(mode="lava"){
  board = new Board(CONFIG.rows, CONFIG.cols, CONFIG.tileTypes);
  hazard = (mode==="lava") ? new LavaHazard() : (mode==="dragon") ? new DragonHazard() : new CeilingHazard();
  gameState = STATE.RUN;
  hideOverlay();
  document.getElementById('comboVal').textContent = "x1";
  comboPill.querySelector('.dot').style.background = "var(--success)";
}
function onWin(){ if(gameState!==STATE.RUN) return; gameState=STATE.WIN; comboPill.querySelector('.dot').style.background="var(--success)"; showOverlay("ĞŸĞ¾Ğ±ĞµĞ´Ğ°!", "ĞœĞ¾Ğ½Ğ°Ñ€Ñ… ÑĞ¿Ğ°ÑÑ‘Ğ½. Ğ¡Ñ‹Ğ³Ñ€Ğ°ĞµĞ¼ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¸Ğ»Ğ¸ ÑĞ¼ĞµĞ½Ğ¸Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼?"); sound.win(); }
function onLose(){ if(gameState!==STATE.RUN) return; gameState=STATE.LOSE; comboPill.querySelector('.dot').style.background="var(--danger)"; showOverlay("ĞŸĞ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ", "ĞĞ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ»Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ÑĞ½Ğ¾Ğ²Ğ°?"); sound.lose(); }

function update(dt){
  if(gameState===STATE.PAUSE) return;
  hazard?.update(dt);
  board?.update(dt);
  // Ğ·Ğ°Ñ‚ÑƒÑ…Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ±Ğ¾
  if(board.comboDecay>0){ board.comboDecay -= dt; if(board.comboDecay<=0){ board.combo = Math.max(1, board.combo - .2); document.getElementById('comboVal').textContent = "x"+board.combo.toFixed(1).replace(".0",""); board.comboDecay = board.combo>1 ? 2.5 : 0; } }
  particles.update(dt);
}
function render(){
  // SCENE
  hazard?.draw(sceneCtx, sceneCanvas.width, sceneCanvas.height);
  // BOARD
  boardCtx.clearRect(0,0, boardCanvas.width, boardCanvas.height);
  board.draw(boardCtx);
  particles.draw(boardCtx);
}
function loop(now){
  const dt = Math.min(0.033, (now - lastT)/1000); lastT = now; timeNow += dt;
  update(dt); render(); requestAnimationFrame(loop);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ’Ğ²Ğ¾Ğ´ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let pointerDown = false;
boardCanvas.addEventListener('pointerdown', (e)=>{
  if(gameState!==STATE.RUN) return;
  sound.init();
  pointerDown = true;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if(cell) board.pointerDown(cell);
});
boardCanvas.addEventListener('pointermove', (e)=>{
  if(!pointerDown || gameState!==STATE.RUN) return;
  const rect = boardCanvas.getBoundingClientRect();
  const cell = board.screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if(cell) board.pointerMove(cell);
});
window.addEventListener('pointerup', ()=>{ if(!pointerDown) return; pointerDown=false; board.pointerUp(); });

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btnRestart').addEventListener('click', ()=> initGame(document.getElementById('mode').value));
document.getElementById('btnPause').addEventListener('click', ()=>{
  if(gameState===STATE.RUN){ gameState=STATE.PAUSE; overlayTitle.textContent="ĞŸĞ°ÑƒĞ·Ğ°"; overlaySub.textContent="Ğ˜Ğ³Ñ€Ğ° Ğ½Ğ° Ğ¿Ğ°ÑƒĞ·Ğµ."; overlay.classList.add('show'); }
  else if(gameState===STATE.PAUSE){ gameState=STATE.RUN; overlay.classList.remove('show'); }
});
btnAgain.addEventListener('click', ()=>{ initGame(document.getElementById('mode').value); });
btnContinue.addEventListener('click', ()=>{ if(gameState===STATE.PAUSE){ gameState=STATE.RUN; } overlay.classList.remove('show'); });
document.getElementById('mode').addEventListener('change', e=> initGame(e.target.value));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ¡Ñ‚Ğ°Ñ€Ñ‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resize(); initGame("lava"); requestAnimationFrame(loop);
</script>
</body>
</html>
